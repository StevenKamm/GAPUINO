<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Hyperbus</title>
<title>Hyperbus</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pulp.css" rel="stylesheet" type="text/css" />
<link href="gap.css" rel="stylesheet" type="text/css" />
<link href="images.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="titlerow">
  <td id="projectlogo"><img alt="Logo" src="gap-logo-55.png" /></td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">PMSIS API</div>
    </td>
  <td id="extralogo"><img alt="GreenWaves" src="greenwaves-logo-55.png" /></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
    <ul class="tablist">
      <script type="text/javascript">
		<!--
		writeComponentTabs.call(this);
		//-->
      </script>
	  </ul>
</div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__Hyperbus.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Hyperbus<div class="ingroups"><a class="el" href="group__groupDrivers.html">Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpi__hyper__conf__t.html">pi_hyper_conf_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpi__hyper__conf.html">pi_hyper_conf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hyperbus configuration structure.  <a href="structpi__hyper__conf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga51954909a3307c12707f21d2d55e30bf"><td class="memItemLeft" align="right" valign="top">typedef struct pi_cl_hyper_req_s&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#ga51954909a3307c12707f21d2d55e30bf">pi_cl_hyper_req_t</a></td></tr>
<tr class="memdesc:ga51954909a3307c12707f21d2d55e30bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hyperbus cluster request structure.  <a href="#ga51954909a3307c12707f21d2d55e30bf">More...</a><br /></td></tr>
<tr class="separator:ga51954909a3307c12707f21d2d55e30bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga8d3cdddd36f387eb50c544cd62d1c014"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#ga8d3cdddd36f387eb50c544cd62d1c014">pi_hyper_type_e</a> <tr class="memdesc:ga8d3cdddd36f387eb50c544cd62d1c014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the device connected to the hyperbus interface.  <a href="group__Hyperbus.html#ga8d3cdddd36f387eb50c544cd62d1c014">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga8d3cdddd36f387eb50c544cd62d1c014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab64b3e22f1c33179452d4e95024ad80e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#gab64b3e22f1c33179452d4e95024ad80e">pi_hyper_ioctl_cmd</a> </td></tr>
<tr class="separator:gab64b3e22f1c33179452d4e95024ad80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacaacb78bae18c6e4f21906b1babdaadd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#gacaacb78bae18c6e4f21906b1babdaadd">pi_hyper_conf_init</a> (struct <a class="el" href="structpi__hyper__conf.html">pi_hyper_conf</a> *conf)</td></tr>
<tr class="memdesc:gacaacb78bae18c6e4f21906b1babdaadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an Hyperbus configuration with default values.  <a href="#gacaacb78bae18c6e4f21906b1babdaadd">More...</a><br /></td></tr>
<tr class="separator:gacaacb78bae18c6e4f21906b1babdaadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef9fe1889c451cf23139d2d72c444080"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#gaef9fe1889c451cf23139d2d72c444080">pi_hyper_open</a> (struct pi_device *device)</td></tr>
<tr class="memdesc:gaef9fe1889c451cf23139d2d72c444080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an Hyperbus device.  <a href="#gaef9fe1889c451cf23139d2d72c444080">More...</a><br /></td></tr>
<tr class="separator:gaef9fe1889c451cf23139d2d72c444080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab829e41ba58a4cb41e589b773ef62da1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#gab829e41ba58a4cb41e589b773ef62da1">pi_hyper_close</a> (struct pi_device *device)</td></tr>
<tr class="memdesc:gab829e41ba58a4cb41e589b773ef62da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an opened Hyperbus device.  <a href="#gab829e41ba58a4cb41e589b773ef62da1">More...</a><br /></td></tr>
<tr class="separator:gab829e41ba58a4cb41e589b773ef62da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa89115f402f27959a4675fa3e5880f61"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#gaa89115f402f27959a4675fa3e5880f61">pi_hyper_ioctl</a> (struct pi_device *device, uint32_t cmd, void *arg)</td></tr>
<tr class="memdesc:gaa89115f402f27959a4675fa3e5880f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically change the device configuration.  <a href="#gaa89115f402f27959a4675fa3e5880f61">More...</a><br /></td></tr>
<tr class="separator:gaa89115f402f27959a4675fa3e5880f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f1918f1a4858ea790c477399d5e23ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hyperbus_8h.html#a17a66bef10debc704ae7712b1b786b4d">PI_INLINE_HYPER_LVL_0</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#ga9f1918f1a4858ea790c477399d5e23ca">pi_hyper_read</a> (struct pi_device *device, uint32_t hyper_addr, void *addr, uint32_t size)</td></tr>
<tr class="memdesc:ga9f1918f1a4858ea790c477399d5e23ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a read copy to the Hyperbus (from Hyperbus to processor).  <a href="#ga9f1918f1a4858ea790c477399d5e23ca">More...</a><br /></td></tr>
<tr class="separator:ga9f1918f1a4858ea790c477399d5e23ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89b210487c55b7a5daf59d319458f1fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hyperbus_8h.html#a17a66bef10debc704ae7712b1b786b4d">PI_INLINE_HYPER_LVL_0</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#ga89b210487c55b7a5daf59d319458f1fb">pi_hyper_read_async</a> (struct pi_device *device, uint32_t hyper_addr, void *addr, uint32_t size, struct pi_task *task)</td></tr>
<tr class="memdesc:ga89b210487c55b7a5daf59d319458f1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an asynchronous read copy to the Hyperbus (from Hyperbus to processor).  <a href="#ga89b210487c55b7a5daf59d319458f1fb">More...</a><br /></td></tr>
<tr class="separator:ga89b210487c55b7a5daf59d319458f1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad59ba31a0f98e4b6a5af3049d0438ccd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hyperbus_8h.html#a17a66bef10debc704ae7712b1b786b4d">PI_INLINE_HYPER_LVL_0</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#gad59ba31a0f98e4b6a5af3049d0438ccd">pi_hyper_write</a> (struct pi_device *device, uint32_t hyper_addr, void *addr, uint32_t size)</td></tr>
<tr class="memdesc:gad59ba31a0f98e4b6a5af3049d0438ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a write copy to the Hyperbus (from processor to Hyperbus).  <a href="#gad59ba31a0f98e4b6a5af3049d0438ccd">More...</a><br /></td></tr>
<tr class="separator:gad59ba31a0f98e4b6a5af3049d0438ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fb5c66f4f80549455800898c52895eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hyperbus_8h.html#a17a66bef10debc704ae7712b1b786b4d">PI_INLINE_HYPER_LVL_0</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#ga0fb5c66f4f80549455800898c52895eb">pi_hyper_write_async</a> (struct pi_device *device, uint32_t hyper_addr, void *addr, uint32_t size, struct pi_task *task)</td></tr>
<tr class="memdesc:ga0fb5c66f4f80549455800898c52895eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an asynchronous write copy to the Hyperbus (from processor to Hyperbus).  <a href="#ga0fb5c66f4f80549455800898c52895eb">More...</a><br /></td></tr>
<tr class="separator:ga0fb5c66f4f80549455800898c52895eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4418d8c20602ece6ba8716c72b18741"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hyperbus_8h.html#a17a66bef10debc704ae7712b1b786b4d">PI_INLINE_HYPER_LVL_0</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#gab4418d8c20602ece6ba8716c72b18741">pi_hyper_read_2d</a> (struct pi_device *device, uint32_t hyper_addr, void *addr, uint32_t size, uint32_t stride, uint32_t length)</td></tr>
<tr class="memdesc:gab4418d8c20602ece6ba8716c72b18741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a 2D read copy (rectangle area) to the Hyperbus (from Hyperbus to processor).  <a href="#gab4418d8c20602ece6ba8716c72b18741">More...</a><br /></td></tr>
<tr class="separator:gab4418d8c20602ece6ba8716c72b18741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga250f35ef1f519b733d5c9b478cea5a5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hyperbus_8h.html#a17a66bef10debc704ae7712b1b786b4d">PI_INLINE_HYPER_LVL_0</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#ga250f35ef1f519b733d5c9b478cea5a5a">pi_hyper_read_2d_async</a> (struct pi_device *device, uint32_t hyper_addr, void *addr, uint32_t size, uint32_t stride, uint32_t length, struct pi_task *task)</td></tr>
<tr class="memdesc:ga250f35ef1f519b733d5c9b478cea5a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an asynchronous 2D read copy (rectangle area) to the Hyperbus (from Hyperbus to processor).  <a href="#ga250f35ef1f519b733d5c9b478cea5a5a">More...</a><br /></td></tr>
<tr class="separator:ga250f35ef1f519b733d5c9b478cea5a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e22dee3999d97d54a9d72c05a6d0b5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hyperbus_8h.html#a17a66bef10debc704ae7712b1b786b4d">PI_INLINE_HYPER_LVL_0</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#ga6e22dee3999d97d54a9d72c05a6d0b5e">pi_hyper_write_2d</a> (struct pi_device *device, uint32_t hyper_addr, void *addr, uint32_t size, uint32_t stride, uint32_t length)</td></tr>
<tr class="memdesc:ga6e22dee3999d97d54a9d72c05a6d0b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a 2D write copy (rectangle area) to the Hyperbus (from processor to Hyperbus).  <a href="#ga6e22dee3999d97d54a9d72c05a6d0b5e">More...</a><br /></td></tr>
<tr class="separator:ga6e22dee3999d97d54a9d72c05a6d0b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf14c55a3db57bd4155f16096215edc35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hyperbus_8h.html#a17a66bef10debc704ae7712b1b786b4d">PI_INLINE_HYPER_LVL_0</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#gaf14c55a3db57bd4155f16096215edc35">pi_hyper_write_2d_async</a> (struct pi_device *device, uint32_t hyper_addr, void *addr, uint32_t size, uint32_t stride, uint32_t length, struct pi_task *task)</td></tr>
<tr class="memdesc:gaf14c55a3db57bd4155f16096215edc35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an asynchronous 2D write copy (rectangle area) to the Hyperbus (from processor to Hyperbus).  <a href="#gaf14c55a3db57bd4155f16096215edc35">More...</a><br /></td></tr>
<tr class="separator:gaf14c55a3db57bd4155f16096215edc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb1ba1d5b6adbcdf23ae32d97756596a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#gaeb1ba1d5b6adbcdf23ae32d97756596a">pi_hyper_reg_get</a> (struct pi_device *device, uint32_t reg_addr, uint8_t *value)</td></tr>
<tr class="separator:gaeb1ba1d5b6adbcdf23ae32d97756596a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d91c627ad8d998e51a99df8d213c073"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#ga3d91c627ad8d998e51a99df8d213c073">pi_hyper_reg_set</a> (struct pi_device *device, uint32_t reg_addr, uint8_t *value)</td></tr>
<tr class="separator:ga3d91c627ad8d998e51a99df8d213c073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68b6f71756facb5f978c6447734b6c43"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#ga68b6f71756facb5f978c6447734b6c43">pi_cl_hyper_read</a> (struct pi_device *device, uint32_t hyper_addr, void *addr, uint32_t size, <a class="el" href="group__Hyperbus.html#ga51954909a3307c12707f21d2d55e30bf">pi_cl_hyper_req_t</a> *req)</td></tr>
<tr class="memdesc:ga68b6f71756facb5f978c6447734b6c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a read copy to the Hyperbus from cluster side (from Hyperbus to processor).  <a href="#ga68b6f71756facb5f978c6447734b6c43">More...</a><br /></td></tr>
<tr class="separator:ga68b6f71756facb5f978c6447734b6c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70a6d7de5c10d2de0f1410151570e5a6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#ga70a6d7de5c10d2de0f1410151570e5a6">pi_cl_hyper_read_2d</a> (struct pi_device *device, uint32_t hyper_addr, void *addr, uint32_t size, uint32_t stride, uint32_t length, <a class="el" href="group__Hyperbus.html#ga51954909a3307c12707f21d2d55e30bf">pi_cl_hyper_req_t</a> *req)</td></tr>
<tr class="memdesc:ga70a6d7de5c10d2de0f1410151570e5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a 2D read copy (rectangle area) to the Hyperbus from cluster side (from Hyperbus to processor).  <a href="#ga70a6d7de5c10d2de0f1410151570e5a6">More...</a><br /></td></tr>
<tr class="separator:ga70a6d7de5c10d2de0f1410151570e5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb67342a2363635276283b9a09b6dd8d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#gaeb67342a2363635276283b9a09b6dd8d">pi_cl_hyper_read_wait</a> (<a class="el" href="group__Hyperbus.html#ga51954909a3307c12707f21d2d55e30bf">pi_cl_hyper_req_t</a> *req)</td></tr>
<tr class="memdesc:gaeb67342a2363635276283b9a09b6dd8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the specified hyperbus request has finished.  <a href="#gaeb67342a2363635276283b9a09b6dd8d">More...</a><br /></td></tr>
<tr class="separator:gaeb67342a2363635276283b9a09b6dd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa867e9da0fa54a79ffd89f42ae1dc51"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#gafa867e9da0fa54a79ffd89f42ae1dc51">pi_cl_hyper_write</a> (struct pi_device *device, uint32_t hyper_addr, void *addr, uint32_t size, <a class="el" href="group__Hyperbus.html#ga51954909a3307c12707f21d2d55e30bf">pi_cl_hyper_req_t</a> *req)</td></tr>
<tr class="memdesc:gafa867e9da0fa54a79ffd89f42ae1dc51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a write copy to the Hyperbus from cluster side (from Hyperbus to processor).  <a href="#gafa867e9da0fa54a79ffd89f42ae1dc51">More...</a><br /></td></tr>
<tr class="separator:gafa867e9da0fa54a79ffd89f42ae1dc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3a1cd35cf4a78a9e1951e87733cf4fe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#gac3a1cd35cf4a78a9e1951e87733cf4fe">pi_cl_hyper_write_2d</a> (struct pi_device *device, uint32_t hyper_addr, void *addr, uint32_t size, uint32_t stride, uint32_t length, <a class="el" href="group__Hyperbus.html#ga51954909a3307c12707f21d2d55e30bf">pi_cl_hyper_req_t</a> *req)</td></tr>
<tr class="memdesc:gac3a1cd35cf4a78a9e1951e87733cf4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a 2D write copy (rectangle area) to the Hyperbus from cluster side (from Hyperbus to processor).  <a href="#gac3a1cd35cf4a78a9e1951e87733cf4fe">More...</a><br /></td></tr>
<tr class="separator:gac3a1cd35cf4a78a9e1951e87733cf4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec50057ab6f8c641941e6c767b3df323"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#gaec50057ab6f8c641941e6c767b3df323">pi_cl_hyper_write_wait</a> (<a class="el" href="group__Hyperbus.html#ga51954909a3307c12707f21d2d55e30bf">pi_cl_hyper_req_t</a> *req)</td></tr>
<tr class="memdesc:gaec50057ab6f8c641941e6c767b3df323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the specified hyperbus request has finished.  <a href="#gaec50057ab6f8c641941e6c767b3df323">More...</a><br /></td></tr>
<tr class="separator:gaec50057ab6f8c641941e6c767b3df323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9acb418839dea0fcaecacd5a4d19dffe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#ga9acb418839dea0fcaecacd5a4d19dffe">pi_cl_hyper_copy</a> (struct pi_device *device, uint32_t hyper_addr, void *addr, uint32_t size, int ext2loc, <a class="el" href="group__Hyperbus.html#ga51954909a3307c12707f21d2d55e30bf">pi_cl_hyper_req_t</a> *req)</td></tr>
<tr class="memdesc:ga9acb418839dea0fcaecacd5a4d19dffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a copy with the Hyperbus from cluster side.  <a href="#ga9acb418839dea0fcaecacd5a4d19dffe">More...</a><br /></td></tr>
<tr class="separator:ga9acb418839dea0fcaecacd5a4d19dffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfd51d4a55e0e81eb65f7dc134abfa68"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Hyperbus.html#gadfd51d4a55e0e81eb65f7dc134abfa68">pi_cl_hyper_copy_2d</a> (struct pi_device *device, uint32_t hyper_addr, void *addr, uint32_t size, uint32_t stride, uint32_t length, int ext2loc, <a class="el" href="group__Hyperbus.html#ga51954909a3307c12707f21d2d55e30bf">pi_cl_hyper_req_t</a> *req)</td></tr>
<tr class="memdesc:gadfd51d4a55e0e81eb65f7dc134abfa68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a 2D copy (rectangle area) with the Hyperbus from cluster side.  <a href="#gadfd51d4a55e0e81eb65f7dc134abfa68">More...</a><br /></td></tr>
<tr class="separator:gadfd51d4a55e0e81eb65f7dc134abfa68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The Hyperbus driver provides support for transferring data between an external Hyperbus chip and the processor running this driver.</p>
<p>This is a driver for the Hyperbus interface. Higher-level drivers can be built on top of this one to target specific devices such as Hyperflash or Hyperram. Please refer to the PMSIS BSP documentation for such drivers. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga51954909a3307c12707f21d2d55e30bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51954909a3307c12707f21d2d55e30bf">&#9670;&nbsp;</a></span>pi_cl_hyper_req_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct pi_cl_hyper_req_s <a class="el" href="group__Hyperbus.html#ga51954909a3307c12707f21d2d55e30bf">pi_cl_hyper_req_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure is used by the runtime to manage a cluster remote copy with the Hyperbus. It must be instantiated once for each copy and must be kept alive until the copy is finished. It can be instantiated as a normal variable, for example as a global variable, a local one on the stack, or through a memory allocator. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gab64b3e22f1c33179452d4e95024ad80e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab64b3e22f1c33179452d4e95024ad80e">&#9670;&nbsp;</a></span>pi_hyper_ioctl_cmd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Hyperbus.html#gab64b3e22f1c33179452d4e95024ad80e">pi_hyper_ioctl_cmd</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>IOCTL command </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggab64b3e22f1c33179452d4e95024ad80eae60d4096cb316bcd48c79bcfd7f14f68"></a>PI_HYPER_IOCTL_SET_LATENCY&#160;</td><td class="fielddoc"><p>Set the device latency. </p>
<p>This command can be used when the interface has been opened to configure the latency suitable for the device. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga8d3cdddd36f387eb50c544cd62d1c014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d3cdddd36f387eb50c544cd62d1c014">&#9670;&nbsp;</a></span>pi_hyper_type_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Hyperbus.html#ga8d3cdddd36f387eb50c544cd62d1c014">pi_hyper_type_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is used to know if the device is a flash or a RAM. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga8d3cdddd36f387eb50c544cd62d1c014a64945940ac9cb7884b8a62f5c91a4de7"></a>PI_HYPER_TYPE_FLASH&#160;</td><td class="fielddoc"><p>Device is an Hyperflash. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga8d3cdddd36f387eb50c544cd62d1c014a054b84810330f746a8fcc6faf0028bcb"></a>PI_HYPER_TYPE_RAM&#160;</td><td class="fielddoc"><p>Device is an Hyperram. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9acb418839dea0fcaecacd5a4d19dffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9acb418839dea0fcaecacd5a4d19dffe">&#9670;&nbsp;</a></span>pi_cl_hyper_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cl_hyper_copy </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hyper_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ext2loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Hyperbus.html#ga51954909a3307c12707f21d2d55e30bf">pi_cl_hyper_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is a remote call that the cluster can issue to the fabric-controller in order to ask for an HyperBus copy. The copy will make an asynchronous transfer between the Hyperbus and one of the processor memory areas. A pointer to a request structure must be provided so that the runtime can properly do the remote call. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the Hyperbus chip on which to do the copy. </td></tr>
    <tr><td class="paramname">hyper_addr</td><td>The address of the copy in the Hyperbus. </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">ext2loc</td><td>1 if the copy is from HyperBus to the chip or 0 for the contrary. </td></tr>
    <tr><td class="paramname">req</td><td>A pointer to the HyperBus request structure. It must be allocated by the caller and kept alive until the copy is finished. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadfd51d4a55e0e81eb65f7dc134abfa68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfd51d4a55e0e81eb65f7dc134abfa68">&#9670;&nbsp;</a></span>pi_cl_hyper_copy_2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cl_hyper_copy_2d </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hyper_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ext2loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Hyperbus.html#ga51954909a3307c12707f21d2d55e30bf">pi_cl_hyper_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is a remote call that the cluster can issue to the fabric-controller in order to ask for an HyperBus copy. The copy will make an asynchronous transfer between the Hyperbus and one of the processor memory areas. A pointer to a request structure must be provided so that the runtime can properly do the remote call. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the Hyperbus chip on which to do the copy. </td></tr>
    <tr><td class="paramname">hyper_addr</td><td>The address of the copy in the Hyperbus. </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">stride</td><td>2D stride, which is the number of bytes which are added to the beginning of the current line to switch to the next one. </td></tr>
    <tr><td class="paramname">length</td><td>2D length, which is the number of transferred bytes after which the driver will switch to the next line. </td></tr>
    <tr><td class="paramname">ext2loc</td><td>1 if the copy is from HyperBus to the chip or 0 for the contrary. </td></tr>
    <tr><td class="paramname">req</td><td>A pointer to the HyperBus request structure. It must be allocated by the caller and kept alive until the copy is finished. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga68b6f71756facb5f978c6447734b6c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68b6f71756facb5f978c6447734b6c43">&#9670;&nbsp;</a></span>pi_cl_hyper_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cl_hyper_read </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hyper_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Hyperbus.html#ga51954909a3307c12707f21d2d55e30bf">pi_cl_hyper_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is a remote call that the cluster can do to the fabric-controller in order to ask for an HyperBus read copy. The copy will make an asynchronous transfer between the Hyperbus and one of the processor memory areas. A pointer to a request structure must be provided so that the runtime can properly do the remote call. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the Hyperbus chip on which to do the copy. </td></tr>
    <tr><td class="paramname">hyper_addr</td><td>The address of the copy in the Hyperbus. </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">req</td><td>A pointer to the HyperBus request structure. It must be allocated by the caller and kept alive until the copy is finished. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga70a6d7de5c10d2de0f1410151570e5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70a6d7de5c10d2de0f1410151570e5a6">&#9670;&nbsp;</a></span>pi_cl_hyper_read_2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cl_hyper_read_2d </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hyper_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Hyperbus.html#ga51954909a3307c12707f21d2d55e30bf">pi_cl_hyper_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is a remote call that the cluster can issue to the fabric-controller in order to ask for an HyperBus read copy. The copy will make an asynchronous transfer between the Hyperbus and one of the processor memory areas. A pointer to a request structure must be provided so that the runtime can properly do the remote call. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the Hyperbus chip on which to do the copy. </td></tr>
    <tr><td class="paramname">hyper_addr</td><td>The address of the copy in the Hyperbus. </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy. </td></tr>
    <tr><td class="paramname">stride</td><td>2D stride, which is the number of bytes which are added to the beginning of the current line to switch to the next one. </td></tr>
    <tr><td class="paramname">length</td><td>2D length, which is the number of transferred bytes after which the driver will switch to the next line. </td></tr>
    <tr><td class="paramname">req</td><td>A pointer to the HyperBus request structure. It must be allocated by the caller and kept alive until the copy is finished. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeb67342a2363635276283b9a09b6dd8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb67342a2363635276283b9a09b6dd8d">&#9670;&nbsp;</a></span>pi_cl_hyper_read_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cl_hyper_read_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Hyperbus.html#ga51954909a3307c12707f21d2d55e30bf">pi_cl_hyper_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This blocks the calling core until the specified cluster remote copy is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafa867e9da0fa54a79ffd89f42ae1dc51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa867e9da0fa54a79ffd89f42ae1dc51">&#9670;&nbsp;</a></span>pi_cl_hyper_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cl_hyper_write </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hyper_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Hyperbus.html#ga51954909a3307c12707f21d2d55e30bf">pi_cl_hyper_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is a remote call that the cluster can issue to the fabric-controller in order to ask for an HyperBus write copy. The copy will make an asynchronous transfer between the Hyperbus and one of the processor memory areas. A pointer to a request structure must be provided so that the runtime can properly do the remote call. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the Hyperbus chip on which to do the copy. </td></tr>
    <tr><td class="paramname">hyper_addr</td><td>The address of the copy in the Hyperbus. </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">req</td><td>A pointer to the HyperBus request structure. It must be allocated by the caller and kept alive until the copy is finished. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac3a1cd35cf4a78a9e1951e87733cf4fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3a1cd35cf4a78a9e1951e87733cf4fe">&#9670;&nbsp;</a></span>pi_cl_hyper_write_2d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cl_hyper_write_2d </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hyper_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Hyperbus.html#ga51954909a3307c12707f21d2d55e30bf">pi_cl_hyper_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is a remote call that the cluster can issue to the fabric-controller in order to ask for an HyperBus write copy. The copy will make an asynchronous transfer between the Hyperbus and one of the processor memory areas. A pointer to a request structure must be provided so that the runtime can properly do the remote call. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the Hyperbus chip on which to do the copy. </td></tr>
    <tr><td class="paramname">hyper_addr</td><td>The address of the copy in the Hyperbus. </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">stride</td><td>2D stride, which is the number of bytes which are added to the beginning of the current line to switch to the next one. </td></tr>
    <tr><td class="paramname">length</td><td>2D length, which is the number of transferred bytes after which the driver will switch to the next line. </td></tr>
    <tr><td class="paramname">req</td><td>A pointer to the HyperBus request structure. It must be allocated by the caller and kept alive until the copy is finished. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaec50057ab6f8c641941e6c767b3df323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec50057ab6f8c641941e6c767b3df323">&#9670;&nbsp;</a></span>pi_cl_hyper_write_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cl_hyper_write_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Hyperbus.html#ga51954909a3307c12707f21d2d55e30bf">pi_cl_hyper_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This blocks the calling core until the specified cluster remote copy is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>The request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab829e41ba58a4cb41e589b773ef62da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab829e41ba58a4cb41e589b773ef62da1">&#9670;&nbsp;</a></span>pi_hyper_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_hyper_close </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to close an opened Hyperbus device once it is not needed anymore, in order to free all allocated resources. Once this function is called, the device is not accessible anymore and must be opened again before being used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device structure of the device to close. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacaacb78bae18c6e4f21906b1babdaadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacaacb78bae18c6e4f21906b1babdaadd">&#9670;&nbsp;</a></span>pi_hyper_conf_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_hyper_conf_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpi__hyper__conf.html">pi_hyper_conf</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The structure containing the configuration must be kept alive until the device is opened.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>A pointer to the Hyperbus configuration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa89115f402f27959a4675fa3e5880f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa89115f402f27959a4675fa3e5880f61">&#9670;&nbsp;</a></span>pi_hyper_ioctl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_hyper_ioctl </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to change part of the device configuration after it has been opened or to control it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
    <tr><td class="paramname">cmd</td><td>The command which specifies which parameters of the driver to modify and for some of them also their values. The command must be one of those defined in pi_spi_ioctl_e. </td></tr>
    <tr><td class="paramname">arg</td><td>An additional value which is required for some parameters when they are set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaef9fe1889c451cf23139d2d72c444080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef9fe1889c451cf23139d2d72c444080">&#9670;&nbsp;</a></span>pi_hyper_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t pi_hyper_open </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function must be called before the Hyperbus device can be used. It will do all the needed configuration to make it usable and initialize the handle used to refer to this opened device when calling other functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the device structure of the device to open. This structure is allocated by the called and must be kept alive until the device is closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="ga9f1918f1a4858ea790c477399d5e23ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f1918f1a4858ea790c477399d5e23ca">&#9670;&nbsp;</a></span>pi_hyper_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hyperbus_8h.html#a17a66bef10debc704ae7712b1b786b4d">PI_INLINE_HYPER_LVL_0</a> void pi_hyper_read </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hyper_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The copy will make a transfer between the Hyperbus and one of the processor memory areas. The caller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the Hyperbus chip on which to do the copy. </td></tr>
    <tr><td class="paramname">hyper_addr</td><td>The address of the copy in the Hyperbus. </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab4418d8c20602ece6ba8716c72b18741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4418d8c20602ece6ba8716c72b18741">&#9670;&nbsp;</a></span>pi_hyper_read_2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hyperbus_8h.html#a17a66bef10debc704ae7712b1b786b4d">PI_INLINE_HYPER_LVL_0</a> void pi_hyper_read_2d </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hyper_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The copy will make a transfer between the Hyperbus and one of the processor memory areas. The caller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the Hyperbus chip on which to do the copy. </td></tr>
    <tr><td class="paramname">hyper_addr</td><td>The address of the copy in the Hyperbus. </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">stride</td><td>2D stride, which is the number of bytes which are added to the beginning of the current line to switch to the next one. </td></tr>
    <tr><td class="paramname">length</td><td>2D length, which is the number of transferred bytes after which the driver will switch to the next line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga250f35ef1f519b733d5c9b478cea5a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga250f35ef1f519b733d5c9b478cea5a5a">&#9670;&nbsp;</a></span>pi_hyper_read_2d_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hyperbus_8h.html#a17a66bef10debc704ae7712b1b786b4d">PI_INLINE_HYPER_LVL_0</a> void pi_hyper_read_2d_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hyper_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct pi_task *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The copy will make an asynchronous transfer between the Hyperbus and one of the processor memory areas. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the Hyperbus chip on which to do the copy. </td></tr>
    <tr><td class="paramname">hyper_addr</td><td>The address of the copy in the Hyperbus. </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">stride</td><td>2D stride, which is the number of bytes which are added to the beginning of the current line to switch to the next one. </td></tr>
    <tr><td class="paramname">length</td><td>2D length, which is the number of transferred bytes after which the driver will switch to the next line. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga89b210487c55b7a5daf59d319458f1fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89b210487c55b7a5daf59d319458f1fb">&#9670;&nbsp;</a></span>pi_hyper_read_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hyperbus_8h.html#a17a66bef10debc704ae7712b1b786b4d">PI_INLINE_HYPER_LVL_0</a> void pi_hyper_read_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hyper_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct pi_task *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The copy will make an asynchronous transfer between the Hyperbus and one of the processor memory areas. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the Hyperbus chip on which to do the copy. </td></tr>
    <tr><td class="paramname">hyper_addr</td><td>The address of the copy in the Hyperbus. </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeb1ba1d5b6adbcdf23ae32d97756596a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb1ba1d5b6adbcdf23ae32d97756596a">&#9670;&nbsp;</a></span>pi_hyper_reg_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_hyper_reg_get </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reg_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3d91c627ad8d998e51a99df8d213c073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d91c627ad8d998e51a99df8d213c073">&#9670;&nbsp;</a></span>pi_hyper_reg_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_hyper_reg_set </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reg_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad59ba31a0f98e4b6a5af3049d0438ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad59ba31a0f98e4b6a5af3049d0438ccd">&#9670;&nbsp;</a></span>pi_hyper_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hyperbus_8h.html#a17a66bef10debc704ae7712b1b786b4d">PI_INLINE_HYPER_LVL_0</a> void pi_hyper_write </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hyper_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The copy will make a transfer between the Hyperbus and one of the processor memory areas. The caller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the Hyperbus chip on which to do the copy. </td></tr>
    <tr><td class="paramname">hyper_addr</td><td>The address of the copy in the Hyperbus. </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6e22dee3999d97d54a9d72c05a6d0b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e22dee3999d97d54a9d72c05a6d0b5e">&#9670;&nbsp;</a></span>pi_hyper_write_2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hyperbus_8h.html#a17a66bef10debc704ae7712b1b786b4d">PI_INLINE_HYPER_LVL_0</a> void pi_hyper_write_2d </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hyper_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The copy will make a transfer between the Hyperbus and one of the processor memory areas. The caller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the Hyperbus chip on which to do the copy. </td></tr>
    <tr><td class="paramname">hyper_addr</td><td>The address of the copy in the Hyperbus. </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">stride</td><td>2D stride, which is the number of bytes which are added to the beginning of the current line to switch to the next one. </td></tr>
    <tr><td class="paramname">length</td><td>2D length, which is the number of transferred bytes after which the driver will switch to the next line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf14c55a3db57bd4155f16096215edc35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf14c55a3db57bd4155f16096215edc35">&#9670;&nbsp;</a></span>pi_hyper_write_2d_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hyperbus_8h.html#a17a66bef10debc704ae7712b1b786b4d">PI_INLINE_HYPER_LVL_0</a> void pi_hyper_write_2d_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hyper_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct pi_task *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The copy will make an asynchronous transfer between the Hyperbus and one of the processor memory areas. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the Hyperbus chip on which to do the copy. </td></tr>
    <tr><td class="paramname">hyper_addr</td><td>The address of the copy in the Hyperbus. </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">stride</td><td>2D stride, which is the number of bytes which are added to the beginning of the current line to switch to the next one. </td></tr>
    <tr><td class="paramname">length</td><td>2D length, which is the number of transferred bytes after which the driver will switch to the next line. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0fb5c66f4f80549455800898c52895eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fb5c66f4f80549455800898c52895eb">&#9670;&nbsp;</a></span>pi_hyper_write_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hyperbus_8h.html#a17a66bef10debc704ae7712b1b786b4d">PI_INLINE_HYPER_LVL_0</a> void pi_hyper_write_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hyper_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct pi_task *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The copy will make an asynchronous transfer between the Hyperbus and one of the processor memory areas. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device descriptor of the Hyperbus chip on which to do the copy. </td></tr>
    <tr><td class="paramname">hyper_addr</td><td>The address of the copy in the Hyperbus. </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the copy in the processor. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the copy </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer. See the documentation of pi_task_t for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Sep 7 2020 11:22:11 for  by GreenWaves Technologies
	<!--
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 
	-->
	</li>
  </ul>
</div>
</body>
</html>
