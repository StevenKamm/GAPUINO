<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>I2S Interface</title>
<title>I2S Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pulp.css" rel="stylesheet" type="text/css" />
<link href="gap.css" rel="stylesheet" type="text/css" />
<link href="images.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="titlerow">
  <td id="projectlogo"><img alt="Logo" src="gap-logo-55.png" /></td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">PMSIS API</div>
    </td>
  <td id="extralogo"><img alt="GreenWaves" src="greenwaves-logo-55.png" /></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
    <ul class="tablist">
      <script type="text/javascript">
		<!--
		writeComponentTabs.call(this);
		//-->
      </script>
	  </ul>
</div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__I2S.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">I2S Interface<div class="ingroups"><a class="el" href="group__groupDrivers.html">Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>I2S (Inter-IC Sound) Interface.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpi__i2s__conf.html">pi_i2s_conf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface configuration options.  <a href="structpi__i2s__conf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga53c8225e2bdfec848af5bea9605b8289"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga53c8225e2bdfec848af5bea9605b8289">PI_I2S_FMT_DATA_FORMAT_I2S</a></td></tr>
<tr class="memdesc:ga53c8225e2bdfec848af5bea9605b8289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard I2S Data Format.  <a href="#ga53c8225e2bdfec848af5bea9605b8289">More...</a><br /></td></tr>
<tr class="separator:ga53c8225e2bdfec848af5bea9605b8289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71ba1b454887900a3f3d8a5c596f5e10"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga71ba1b454887900a3f3d8a5c596f5e10">PI_I2S_FMT_DATA_FORMAT_PDM</a></td></tr>
<tr class="memdesc:ga71ba1b454887900a3f3d8a5c596f5e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pulse-Density Modulation Format.  <a href="#ga71ba1b454887900a3f3d8a5c596f5e10">More...</a><br /></td></tr>
<tr class="separator:ga71ba1b454887900a3f3d8a5c596f5e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f9e71d2293b7b54dd39186fd92147f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga3f9e71d2293b7b54dd39186fd92147f7">PI_I2S_CH_FMT_DATA_ORDER_MSB</a></td></tr>
<tr class="memdesc:ga3f9e71d2293b7b54dd39186fd92147f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data order MSB.  <a href="#ga3f9e71d2293b7b54dd39186fd92147f7">More...</a><br /></td></tr>
<tr class="separator:ga3f9e71d2293b7b54dd39186fd92147f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f98478a595313df719b3749c8bc982b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga8f98478a595313df719b3749c8bc982b">PI_I2S_CH_FMT_DATA_ORDER_LSB</a></td></tr>
<tr class="memdesc:ga8f98478a595313df719b3749c8bc982b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data order LSB.  <a href="#ga8f98478a595313df719b3749c8bc982b">More...</a><br /></td></tr>
<tr class="separator:ga8f98478a595313df719b3749c8bc982b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8620b0e2b1f5919183bb6c5ecab894ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga8620b0e2b1f5919183bb6c5ecab894ec">PI_I2S_CH_FMT_DATA_ALIGN_LEFT</a></td></tr>
<tr class="memdesc:ga8620b0e2b1f5919183bb6c5ecab894ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data alignment left.  <a href="#ga8620b0e2b1f5919183bb6c5ecab894ec">More...</a><br /></td></tr>
<tr class="separator:ga8620b0e2b1f5919183bb6c5ecab894ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3c8ca1b0e00feaf8658a1f46dcbafb3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#gae3c8ca1b0e00feaf8658a1f46dcbafb3">PI_I2S_CH_FMT_DATA_ALIGN_RIGHT</a></td></tr>
<tr class="memdesc:gae3c8ca1b0e00feaf8658a1f46dcbafb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data alignment right.  <a href="#gae3c8ca1b0e00feaf8658a1f46dcbafb3">More...</a><br /></td></tr>
<tr class="separator:gae3c8ca1b0e00feaf8658a1f46dcbafb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6da49a41b6484b4b53b1da184df86e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga6da49a41b6484b4b53b1da184df86e4d">PI_I2S_CH_FMT_DATA_SIGN_NO_EXTEND</a></td></tr>
<tr class="memdesc:ga6da49a41b6484b4b53b1da184df86e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data sign extension disabled.  <a href="#ga6da49a41b6484b4b53b1da184df86e4d">More...</a><br /></td></tr>
<tr class="separator:ga6da49a41b6484b4b53b1da184df86e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15486fd11caad5f9dc68abc37641ffd1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga15486fd11caad5f9dc68abc37641ffd1">PI_I2S_CH_FMT_DATA_SIGN_EXTEND</a></td></tr>
<tr class="memdesc:ga15486fd11caad5f9dc68abc37641ffd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data sign extension enabled.  <a href="#ga15486fd11caad5f9dc68abc37641ffd1">More...</a><br /></td></tr>
<tr class="separator:ga15486fd11caad5f9dc68abc37641ffd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga600f13ea5c348a26072f7ce83fccc797"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga600f13ea5c348a26072f7ce83fccc797">PI_I2S_OPT_PINGPONG</a></td></tr>
<tr class="memdesc:ga600f13ea5c348a26072f7ce83fccc797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ping pong mode.  <a href="#ga600f13ea5c348a26072f7ce83fccc797">More...</a><br /></td></tr>
<tr class="separator:ga600f13ea5c348a26072f7ce83fccc797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef0687d1eedb34b73e491e238a692974"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#gaef0687d1eedb34b73e491e238a692974">PI_I2S_OPT_MEM_SLAB</a></td></tr>
<tr class="memdesc:gaef0687d1eedb34b73e491e238a692974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mem slab mode.  <a href="#gaef0687d1eedb34b73e491e238a692974">More...</a><br /></td></tr>
<tr class="separator:gaef0687d1eedb34b73e491e238a692974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7250dab36c2c078a3aeeb85147238dd2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga7250dab36c2c078a3aeeb85147238dd2">PI_I2S_OPT_FULL_DUPLEX</a></td></tr>
<tr class="memdesc:ga7250dab36c2c078a3aeeb85147238dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full duplex mode.  <a href="#ga7250dab36c2c078a3aeeb85147238dd2">More...</a><br /></td></tr>
<tr class="separator:ga7250dab36c2c078a3aeeb85147238dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga007d82307a0b15eba5225295d82f2d66"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga007d82307a0b15eba5225295d82f2d66">PI_I2S_OPT_DISABLED</a></td></tr>
<tr class="memdesc:ga007d82307a0b15eba5225295d82f2d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the channel.  <a href="#ga007d82307a0b15eba5225295d82f2d66">More...</a><br /></td></tr>
<tr class="separator:ga007d82307a0b15eba5225295d82f2d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea05e79dc0cc7340372f86e028964468"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#gaea05e79dc0cc7340372f86e028964468">PI_I2S_OPT_ENABLED</a></td></tr>
<tr class="memdesc:gaea05e79dc0cc7340372f86e028964468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the channel.  <a href="#gaea05e79dc0cc7340372f86e028964468">More...</a><br /></td></tr>
<tr class="separator:gaea05e79dc0cc7340372f86e028964468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacd853741e4d588dccb38be8afab80cd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#gaacd853741e4d588dccb38be8afab80cd">PI_I2S_OPT_IS_TX</a></td></tr>
<tr class="memdesc:gaacd853741e4d588dccb38be8afab80cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure TX channel.  <a href="#gaacd853741e4d588dccb38be8afab80cd">More...</a><br /></td></tr>
<tr class="separator:gaacd853741e4d588dccb38be8afab80cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26e07182459fd171b3fc4d3edbeff880"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga26e07182459fd171b3fc4d3edbeff880">PI_I2S_OPT_IS_RX</a></td></tr>
<tr class="memdesc:ga26e07182459fd171b3fc4d3edbeff880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure RX channel.  <a href="#ga26e07182459fd171b3fc4d3edbeff880">More...</a><br /></td></tr>
<tr class="separator:ga26e07182459fd171b3fc4d3edbeff880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1a012309411cba2a642b5c7f65331b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#gae1a012309411cba2a642b5c7f65331b2">PI_I2S_OPT_LOOPBACK</a></td></tr>
<tr class="memdesc:gae1a012309411cba2a642b5c7f65331b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">TX loopback.  <a href="#gae1a012309411cba2a642b5c7f65331b2">More...</a><br /></td></tr>
<tr class="separator:gae1a012309411cba2a642b5c7f65331b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cfa12b77fd1675d2e60d4e3f88379be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga9cfa12b77fd1675d2e60d4e3f88379be">PI_I2S_OPT_TDM</a></td></tr>
<tr class="memdesc:ga9cfa12b77fd1675d2e60d4e3f88379be"><td class="mdescLeft">&#160;</td><td class="mdescRight">TDM mode.  <a href="#ga9cfa12b77fd1675d2e60d4e3f88379be">More...</a><br /></td></tr>
<tr class="separator:ga9cfa12b77fd1675d2e60d4e3f88379be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga675b01cbefa1e30c4f22593f3b215382"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga675b01cbefa1e30c4f22593f3b215382">PI_I2S_OPT_INT_CLK</a></td></tr>
<tr class="memdesc:ga675b01cbefa1e30c4f22593f3b215382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use internal clock.  <a href="#ga675b01cbefa1e30c4f22593f3b215382">More...</a><br /></td></tr>
<tr class="separator:ga675b01cbefa1e30c4f22593f3b215382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5011951ff4d24d5767d69b082174c010"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga5011951ff4d24d5767d69b082174c010">PI_I2S_OPT_EXT_CLK</a></td></tr>
<tr class="memdesc:ga5011951ff4d24d5767d69b082174c010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use external clock.  <a href="#ga5011951ff4d24d5767d69b082174c010">More...</a><br /></td></tr>
<tr class="separator:ga5011951ff4d24d5767d69b082174c010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a58eec54905c6ef8438fc46666205e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga8a58eec54905c6ef8438fc46666205e6">PI_I2S_OPT_INT_WS</a></td></tr>
<tr class="memdesc:ga8a58eec54905c6ef8438fc46666205e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use internal word strobe.  <a href="#ga8a58eec54905c6ef8438fc46666205e6">More...</a><br /></td></tr>
<tr class="separator:ga8a58eec54905c6ef8438fc46666205e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa57ca846496ba169f152edb1e0d91bab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#gaa57ca846496ba169f152edb1e0d91bab">PI_I2S_OPT_EXT_WS</a></td></tr>
<tr class="memdesc:gaa57ca846496ba169f152edb1e0d91bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use external word strobe.  <a href="#gaa57ca846496ba169f152edb1e0d91bab">More...</a><br /></td></tr>
<tr class="separator:gaa57ca846496ba169f152edb1e0d91bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac17138910d0f85480aee50327eeb1c33"><td class="memItemLeft" align="right" valign="top">typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#gac17138910d0f85480aee50327eeb1c33">pi_i2s_fmt_t</a></td></tr>
<tr class="separator:gac17138910d0f85480aee50327eeb1c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada08e871d49745f77f9128417973a51b"><td class="memItemLeft" align="right" valign="top">typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#gada08e871d49745f77f9128417973a51b">pi_i2s_opt_t</a></td></tr>
<tr class="separator:gada08e871d49745f77f9128417973a51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaa09e82f1919334e89ff98c2510616385"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#gaa09e82f1919334e89ff98c2510616385">pi_i2s_ioctl_cmd_e</a> <tr class="memdesc:gaa09e82f1919334e89ff98c2510616385"><td class="mdescLeft">&#160;</td><td class="mdescRight">IOCTL command.  <a href="group__I2S.html#gaa09e82f1919334e89ff98c2510616385">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gaa09e82f1919334e89ff98c2510616385"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga81800a8f3373400f3c187c205028b3db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga81800a8f3373400f3c187c205028b3db">pi_i2s_setup</a> (uint32_t flags)</td></tr>
<tr class="memdesc:ga81800a8f3373400f3c187c205028b3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup specific I2S aspects.  <a href="#ga81800a8f3373400f3c187c205028b3db">More...</a><br /></td></tr>
<tr class="separator:ga81800a8f3373400f3c187c205028b3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1657fc62c170475ec18210f1a57c329c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga1657fc62c170475ec18210f1a57c329c">pi_i2s_conf_init</a> (struct <a class="el" href="structpi__i2s__conf.html">pi_i2s_conf</a> *conf)</td></tr>
<tr class="memdesc:ga1657fc62c170475ec18210f1a57c329c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an I2S configuration with default values.  <a href="#ga1657fc62c170475ec18210f1a57c329c">More...</a><br /></td></tr>
<tr class="separator:ga1657fc62c170475ec18210f1a57c329c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac735eb27206159797c19a499c08a6cc5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#gac735eb27206159797c19a499c08a6cc5">pi_i2s_open</a> (struct pi_device *device)</td></tr>
<tr class="memdesc:gac735eb27206159797c19a499c08a6cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an I2S device.  <a href="#gac735eb27206159797c19a499c08a6cc5">More...</a><br /></td></tr>
<tr class="separator:gac735eb27206159797c19a499c08a6cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga899113b680f7f359c9dc69313e3bfd91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga899113b680f7f359c9dc69313e3bfd91">pi_i2s_close</a> (struct pi_device *device)</td></tr>
<tr class="memdesc:ga899113b680f7f359c9dc69313e3bfd91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an opened I2S device.  <a href="#ga899113b680f7f359c9dc69313e3bfd91">More...</a><br /></td></tr>
<tr class="separator:ga899113b680f7f359c9dc69313e3bfd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6872494c60665461c4edb2b44d01c434"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga6872494c60665461c4edb2b44d01c434">pi_i2s_ioctl</a> (struct pi_device *device, uint32_t cmd, void *arg)</td></tr>
<tr class="memdesc:ga6872494c60665461c4edb2b44d01c434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically change the device configuration.  <a href="#ga6872494c60665461c4edb2b44d01c434">More...</a><br /></td></tr>
<tr class="separator:ga6872494c60665461c4edb2b44d01c434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac863071a455cc4ecde8b458650ddc6f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#gac863071a455cc4ecde8b458650ddc6f4">pi_i2s_read</a> (struct pi_device *dev, void **mem_block, size_t *size)</td></tr>
<tr class="memdesc:gac863071a455cc4ecde8b458650ddc6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the RX queue.  <a href="#gac863071a455cc4ecde8b458650ddc6f4">More...</a><br /></td></tr>
<tr class="separator:gac863071a455cc4ecde8b458650ddc6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4811af1f7fcd3a58e24f0e53eab040c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga4811af1f7fcd3a58e24f0e53eab040c7">pi_i2s_read_async</a> (struct pi_device *dev, pi_task_t *task)</td></tr>
<tr class="memdesc:ga4811af1f7fcd3a58e24f0e53eab040c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data asynchronously from the RX queue.  <a href="#ga4811af1f7fcd3a58e24f0e53eab040c7">More...</a><br /></td></tr>
<tr class="separator:ga4811af1f7fcd3a58e24f0e53eab040c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0694992fc5b378d2b37ca25b5f2fe813"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga0694992fc5b378d2b37ca25b5f2fe813">pi_i2s_write</a> (struct pi_device *dev, void *mem_block, size_t size)</td></tr>
<tr class="memdesc:ga0694992fc5b378d2b37ca25b5f2fe813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the TX queue of a channel.  <a href="#ga0694992fc5b378d2b37ca25b5f2fe813">More...</a><br /></td></tr>
<tr class="separator:ga0694992fc5b378d2b37ca25b5f2fe813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4207e7758220e085a86eac7c7c400703"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga4207e7758220e085a86eac7c7c400703">pi_i2s_write_async</a> (struct pi_device *dev, void *mem_block, size_t size, pi_task_t *task)</td></tr>
<tr class="memdesc:ga4207e7758220e085a86eac7c7c400703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data asynchronously to the TX queue of a channel.  <a href="#ga4207e7758220e085a86eac7c7c400703">More...</a><br /></td></tr>
<tr class="separator:ga4207e7758220e085a86eac7c7c400703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaad16e69985648b8549512e451a2b92"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#gafaad16e69985648b8549512e451a2b92">pi_i2s_channel_read</a> (struct pi_device *dev, int channel, void **mem_block, size_t *size)</td></tr>
<tr class="memdesc:gafaad16e69985648b8549512e451a2b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from the RX queue of a channel in TDM mode.  <a href="#gafaad16e69985648b8549512e451a2b92">More...</a><br /></td></tr>
<tr class="separator:gafaad16e69985648b8549512e451a2b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2017943851ac530f8b17d24be296315"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#gab2017943851ac530f8b17d24be296315">pi_i2s_channel_read_async</a> (struct pi_device *dev, int channel, pi_task_t *task)</td></tr>
<tr class="memdesc:gab2017943851ac530f8b17d24be296315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data asynchronously from the RX queue of a channel in TDM mode.  <a href="#gab2017943851ac530f8b17d24be296315">More...</a><br /></td></tr>
<tr class="separator:gab2017943851ac530f8b17d24be296315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ccba1a796f9cc90c4d9ec24b2c5040d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga0ccba1a796f9cc90c4d9ec24b2c5040d">pi_i2s_read_status</a> (pi_task_t *task, void **mem_block, size_t *size)</td></tr>
<tr class="memdesc:ga0ccba1a796f9cc90c4d9ec24b2c5040d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the status of an asynchronous read.  <a href="#ga0ccba1a796f9cc90c4d9ec24b2c5040d">More...</a><br /></td></tr>
<tr class="separator:ga0ccba1a796f9cc90c4d9ec24b2c5040d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bf00b6e30588c86b0ce6cec8723c5ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga9bf00b6e30588c86b0ce6cec8723c5ef">pi_i2s_channel_write</a> (struct pi_device *dev, int channel, void *mem_block, size_t size)</td></tr>
<tr class="memdesc:ga9bf00b6e30588c86b0ce6cec8723c5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to the TX queue of a channel in TDM mode.  <a href="#ga9bf00b6e30588c86b0ce6cec8723c5ef">More...</a><br /></td></tr>
<tr class="separator:ga9bf00b6e30588c86b0ce6cec8723c5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98f6d2597a9e1191fdf5b52acbd8ef4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga98f6d2597a9e1191fdf5b52acbd8ef4a">pi_i2s_channel_write_async</a> (struct pi_device *dev, int channel, void *mem_block, size_t size, pi_task_t *task)</td></tr>
<tr class="memdesc:ga98f6d2597a9e1191fdf5b52acbd8ef4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data asynchronously to the TX queue of a channel in TDM mode.  <a href="#ga98f6d2597a9e1191fdf5b52acbd8ef4a">More...</a><br /></td></tr>
<tr class="separator:ga98f6d2597a9e1191fdf5b52acbd8ef4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga791f0081e66282503606188a6564c5e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2S.html#ga791f0081e66282503606188a6564c5e0">pi_i2s_write_status</a> (pi_task_t *task)</td></tr>
<tr class="memdesc:ga791f0081e66282503606188a6564c5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the status of an asynchronous write.  <a href="#ga791f0081e66282503606188a6564c5e0">More...</a><br /></td></tr>
<tr class="separator:ga791f0081e66282503606188a6564c5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The I2S API provides support for the I2S interface. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga8620b0e2b1f5919183bb6c5ecab894ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8620b0e2b1f5919183bb6c5ecab894ec">&#9670;&nbsp;</a></span>PI_I2S_CH_FMT_DATA_ALIGN_LEFT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PI_I2S_CH_FMT_DATA_ALIGN_LEFT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Left Justified. </p>

</div>
</div>
<a id="gae3c8ca1b0e00feaf8658a1f46dcbafb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3c8ca1b0e00feaf8658a1f46dcbafb3">&#9670;&nbsp;</a></span>PI_I2S_CH_FMT_DATA_ALIGN_RIGHT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PI_I2S_CH_FMT_DATA_ALIGN_RIGHT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Right Justified. </p>

</div>
</div>
<a id="ga8f98478a595313df719b3749c8bc982b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f98478a595313df719b3749c8bc982b">&#9670;&nbsp;</a></span>PI_I2S_CH_FMT_DATA_ORDER_LSB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PI_I2S_CH_FMT_DATA_ORDER_LSB</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data bits are transferred LSB first. </p>

</div>
</div>
<a id="ga3f9e71d2293b7b54dd39186fd92147f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f9e71d2293b7b54dd39186fd92147f7">&#9670;&nbsp;</a></span>PI_I2S_CH_FMT_DATA_ORDER_MSB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PI_I2S_CH_FMT_DATA_ORDER_MSB</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data bits are transferred MSB first. </p>

</div>
</div>
<a id="ga15486fd11caad5f9dc68abc37641ffd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15486fd11caad5f9dc68abc37641ffd1">&#9670;&nbsp;</a></span>PI_I2S_CH_FMT_DATA_SIGN_EXTEND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PI_I2S_CH_FMT_DATA_SIGN_EXTEND</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data are sign extended when I2S data size is inferior to memory data size. For example when I2S data are on 16 bits but are stored in a 32 bits word, MSB sign is extended. </p>

</div>
</div>
<a id="ga6da49a41b6484b4b53b1da184df86e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6da49a41b6484b4b53b1da184df86e4d">&#9670;&nbsp;</a></span>PI_I2S_CH_FMT_DATA_SIGN_NO_EXTEND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PI_I2S_CH_FMT_DATA_SIGN_NO_EXTEND</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data are not sign extended when I2S data size is inferior to memory data size. </p>

</div>
</div>
<a id="ga53c8225e2bdfec848af5bea9605b8289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53c8225e2bdfec848af5bea9605b8289">&#9670;&nbsp;</a></span>PI_I2S_FMT_DATA_FORMAT_I2S</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PI_I2S_FMT_DATA_FORMAT_I2S</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serial data is transmitted in two's complement with the MSB first. Both Word Select (WS) and Serial Data (SD) signals are sampled on the rising edge of the clock signal (SCK). The MSB is always sent one clock period after the WS changes. Left channel data are sent first indicated by WS = 0, followed by right channel data indicated by WS = 1. </p><pre class="fragment">   -. .-. .-. .-. .-. .-. .-. .-. .-. .-. .-. .-. .-. .-. .-. .-. .-. .-.
SCK '-' '-' '-' '-' '-' '-' '-' '-' '-' '-' '-' '-' '-' '-' '-' '-' '-' '
   -.                               .-------------------------------.
WS  '-------------------------------'                               '----
   -.---.---.---.---.---.---.---.---.---.---.---.---.---.---.---.---.---.
SD  |   |MSB|   |...|   |LSB| x |...| x |MSB|   |...|   |LSB| x |...| x |
   -'---'---'---'---'---'---'---'---'---'---'---'---'---'---'---'---'---'
        | Left channel                  | Right channel                 |</pre> 
</div>
</div>
<a id="ga71ba1b454887900a3f3d8a5c596f5e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71ba1b454887900a3f3d8a5c596f5e10">&#9670;&nbsp;</a></span>PI_I2S_FMT_DATA_FORMAT_PDM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PI_I2S_FMT_DATA_FORMAT_PDM</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serial data is transmitted using the pulse-density modulation. Each sample is a one bit pulse, where the density of the pulses gives the amplitude of the signal. The driver will filter the input signals so that classic PCM samples are stored in the buffers. In single channel mode, the bits are transmitted on clock signal (CLK) rising edges. In dual channel mode, left chanel is transmitted on SCK rising edges and right channel on SCK falling edges. Word Select (WS) is ignored. </p>

</div>
</div>
<a id="ga007d82307a0b15eba5225295d82f2d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga007d82307a0b15eba5225295d82f2d66">&#9670;&nbsp;</a></span>PI_I2S_OPT_DISABLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PI_I2S_OPT_DISABLED</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If set, this desactivates the channel being configured (either RX or TX). Once the sampling is running, this will make sure this channel is not receiving or sending samples. </p>

</div>
</div>
<a id="gaea05e79dc0cc7340372f86e028964468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea05e79dc0cc7340372f86e028964468">&#9670;&nbsp;</a></span>PI_I2S_OPT_ENABLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PI_I2S_OPT_ENABLED</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If set, this activates the channel being configured (either RX or TX). Once the sampling is running, this will make sure this channel is receiving or sending samples. </p>

</div>
</div>
<a id="ga5011951ff4d24d5767d69b082174c010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5011951ff4d24d5767d69b082174c010">&#9670;&nbsp;</a></span>PI_I2S_OPT_EXT_CLK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PI_I2S_OPT_EXT_CLK</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this option is specified, no clock is generated and an external clock is used. </p>

</div>
</div>
<a id="gaa57ca846496ba169f152edb1e0d91bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa57ca846496ba169f152edb1e0d91bab">&#9670;&nbsp;</a></span>PI_I2S_OPT_EXT_WS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PI_I2S_OPT_EXT_WS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this option is specified, no word strobe is generated and an external one is used. </p>

</div>
</div>
<a id="ga7250dab36c2c078a3aeeb85147238dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7250dab36c2c078a3aeeb85147238dd2">&#9670;&nbsp;</a></span>PI_I2S_OPT_FULL_DUPLEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PI_I2S_OPT_FULL_DUPLEX</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The normal and default mode is to use a single pin for both TX and RX. In full duplex mode, RX and TX will use 2 different pins(called sdi and sdo so that samples can be received and sent at the same time). </p>

</div>
</div>
<a id="ga675b01cbefa1e30c4f22593f3b215382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga675b01cbefa1e30c4f22593f3b215382">&#9670;&nbsp;</a></span>PI_I2S_OPT_INT_CLK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PI_I2S_OPT_INT_CLK</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clock is generated internally from SOC's clock.</p>
<p>This is default clock source. </p>

</div>
</div>
<a id="ga8a58eec54905c6ef8438fc46666205e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a58eec54905c6ef8438fc46666205e6">&#9670;&nbsp;</a></span>PI_I2S_OPT_INT_WS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PI_I2S_OPT_INT_WS</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>WS signal is generated internally from SCK signal.</p>
<p>This is default WS source. </p>

</div>
</div>
<a id="ga26e07182459fd171b3fc4d3edbeff880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26e07182459fd171b3fc4d3edbeff880">&#9670;&nbsp;</a></span>PI_I2S_OPT_IS_RX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PI_I2S_OPT_IS_RX</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If set, the configuration will apply to the RX channel and won't change anything for what concerns the TX channel. Note that this does not prevent from using the TX channel, they must just be configured separately.</p>
<p>Setting this configuration allows to receive data from microphones to memory. </p>

</div>
</div>
<a id="gaacd853741e4d588dccb38be8afab80cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacd853741e4d588dccb38be8afab80cd">&#9670;&nbsp;</a></span>PI_I2S_OPT_IS_TX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PI_I2S_OPT_IS_TX</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If set, the configuration will apply to the TX channel and won't change anything for what concerns the RX channel. Note that this does not prevent from using the RX channel, they must just be configured separately.</p>
<p>Setting this configuration allows to send data from memory to speakers. </p>

</div>
</div>
<a id="gae1a012309411cba2a642b5c7f65331b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1a012309411cba2a642b5c7f65331b2">&#9670;&nbsp;</a></span>PI_I2S_OPT_LOOPBACK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PI_I2S_OPT_LOOPBACK</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If set, this activates an internal loopback between the RX pin and TX pin. All data received on the RX will be sent to the TX pin. Note that this does not prevent from receiving data. Data received on the RX can be sent both to a memory buffer (if RX channel is enabled) and to the TX (if the loopback is enabled). The loopback must be applied on the TX channel. </p>

</div>
</div>
<a id="gaef0687d1eedb34b73e491e238a692974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef0687d1eedb34b73e491e238a692974">&#9670;&nbsp;</a></span>PI_I2S_OPT_MEM_SLAB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PI_I2S_OPT_MEM_SLAB</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In mem slab mode TX output or RX sampling will keep alternating between a a set of buffers given by the user. Memory slab pointed to by the mem_slab field has to be defined and initialized by the user. For I2S driver to function correctly number of memory blocks in a slab has to be at least 2 per queue. Size of the memory block should be multiple of frame_size where frame_size = (channels * word_size_bytes). As an example 16 bit word will occupy 2 bytes, 24 or 32 bit word will occupy 4 bytes. </p>

</div>
</div>
<a id="ga600f13ea5c348a26072f7ce83fccc797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga600f13ea5c348a26072f7ce83fccc797">&#9670;&nbsp;</a></span>PI_I2S_OPT_PINGPONG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PI_I2S_OPT_PINGPONG</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In ping pong mode TX output or RX sampling will keep alternating between a ping buffer and a pong buffer. This is normally used in audio streams when one buffer is being populated while the other is being played (DMAed) and vice versa. So, in this mode, 2 sets of buffers fixed in size are used. These 2 buffers must be given in the configuration when the driver is opened and kept alive until the driver is closed. </p>

</div>
</div>
<a id="ga9cfa12b77fd1675d2e60d4e3f88379be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cfa12b77fd1675d2e60d4e3f88379be">&#9670;&nbsp;</a></span>PI_I2S_OPT_TDM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PI_I2S_OPT_TDM</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In TDM mode, the same interface is time-multiplexed to transmit data for multiple channels where each channel can have a specific configuration. As for classic I2S mode, TX and RX channels are grouped together within a slot. Each slot can send and receive 1 data per frame. In this mode each slot must be configured separately using the I2S configuration. Each slot can have an RX and a TX channel. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gac17138910d0f85480aee50327eeb1c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac17138910d0f85480aee50327eeb1c33">&#9670;&nbsp;</a></span>pi_i2s_fmt_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t <a class="el" href="group__I2S.html#gac17138910d0f85480aee50327eeb1c33">pi_i2s_fmt_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gada08e871d49745f77f9128417973a51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada08e871d49745f77f9128417973a51b">&#9670;&nbsp;</a></span>pi_i2s_opt_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t <a class="el" href="group__I2S.html#gada08e871d49745f77f9128417973a51b">pi_i2s_opt_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaa09e82f1919334e89ff98c2510616385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa09e82f1919334e89ff98c2510616385">&#9670;&nbsp;</a></span>pi_i2s_ioctl_cmd_e</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__I2S.html#gaa09e82f1919334e89ff98c2510616385">pi_i2s_ioctl_cmd_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa09e82f1919334e89ff98c2510616385a9fc5a4dc1e57fd420ebe947d3a2f6665"></a>PI_I2S_IOCTL_START&#160;</td><td class="fielddoc"><p>Start the transmission / reception of data. </p>
<p>This command can be used when the interface has been opened or stopped to start sampling. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa09e82f1919334e89ff98c2510616385a367d4c7e0071fd5f69f5ddc38602d3d7"></a>PI_I2S_IOCTL_STOP&#160;</td><td class="fielddoc"><p>Stop the transmission / reception of data. </p>
<p>Stop the transmission / reception of data at the end of the current memory block. This command can be used when the interface is sampling and is stopping the interface. When the current TX / RX block is transmitted / received the interface is stopped. Subsequent START command will resume transmission / reception where it stopped. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa09e82f1919334e89ff98c2510616385a66d22cfd5c3f7df2115cd16c318421b8"></a>PI_I2S_IOCTL_CONF_SET&#160;</td><td class="fielddoc"><p>Configure a channel in TDM mode. </p>
<p>In TDM mode, the same interface is time-multiplexed to transmit data for multiple channels, and each channel can have a specific configuration. This command can be used to give the configuration of one channel. The argument must be a pointer to a structure of type struct <a class="el" href="structpi__i2s__conf.html" title="Interface configuration options. ">pi_i2s_conf</a> containing the channel configuration. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa09e82f1919334e89ff98c2510616385a31eedbbe119126949fa4f748bca9d570"></a>PI_I2S_IOCTL_CONF_GET&#160;</td><td class="fielddoc"><p>Get the current configuration of a channel in TDM mode. </p>
<p>In TDM mode, the same interface is time-multiplexed to transmit data for multiple channels, and each channel can have a specific configuration. This command can be used to get the current configuration of one channel. The argument must be a pointer to a structure of type struct <a class="el" href="structpi__i2s__conf.html" title="Interface configuration options. ">pi_i2s_conf</a> where the current channel configuration will be stored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa09e82f1919334e89ff98c2510616385a9144f7aa1479585b53490cc718866eba"></a>PI_I2S_IOCTL_CLOCK_ENABLE&#160;</td><td class="fielddoc"><p>Enable clock. </p>
<p>Enable clock for the i2s interface. This command does not sample data, and does not save data. It allows the interface to receive clock signals from SoC and propgate it to slave devices on end line. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa09e82f1919334e89ff98c2510616385ae81f8077b182add8000876e060b2042f"></a>PI_I2S_IOCTL_CLOCK_DISABLE&#160;</td><td class="fielddoc"><p>Disable clock. </p>
<p>Disable clock for the i2s interface. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gafaad16e69985648b8549512e451a2b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaad16e69985648b8549512e451a2b92">&#9670;&nbsp;</a></span>pi_i2s_channel_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_i2s_channel_read </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>mem_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data received by the I2S interface is stored in the RX queue consisting of two memory blocks preallocated by the user and given to the driver in the configuration. Calling this function will return the next available buffer to the caller, which has to use it before the sampling for this buffer starts again.</p>
<p>The data is read in chunks equal to the size of the memory block.</p>
<p>This will return data for the specified channel and must only be used in TDM mode.</p>
<p>If there is no data in the RX queue the function will block waiting for the next RX memory block to fill in.</p>
<p>Due to hardware constraints, the address of the buffer must be aligned on 4 bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Pointer to the device structure for the driver instance. </td></tr>
    <tr><td class="paramname">channel</td><td>ID of the slot, from 0 to the number of channels minus 1. </td></tr>
    <tr><td class="paramname">mem_block</td><td>Pointer to the variable storing the address of the RX memory block containing received data. </td></tr>
    <tr><td class="paramname">size</td><td>Pointer to the variable storing the number of bytes read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If successful, -1 if not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab2017943851ac530f8b17d24be296315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2017943851ac530f8b17d24be296315">&#9670;&nbsp;</a></span>pi_i2s_channel_read_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_i2s_channel_read_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data received by the I2S interface is stored in the RX queue consisting of two memory blocks preallocated by the user and given to the driver in the configuration. Calling this function will return the next available buffer to the caller, which has to use it before the sampling for this buffer starts again.</p>
<p>The data is read in chunks equal to the size of the memory block.</p>
<p>This will return data for the specified channel and must only be used in TDM mode.</p>
<p>The specified task will be pushed as soon as data is ready in the RX queue, and the information about the memory block and the size will be available in the task.</p>
<p>Due to hardware constraints, the address of the buffer must be aligned on 4 bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Pointer to the device structure for the driver instance. </td></tr>
    <tr><td class="paramname">channel</td><td>ID of the slot, from 0 to the number of channels minus 1. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If successful, -1 if not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9bf00b6e30588c86b0ce6cec8723c5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bf00b6e30588c86b0ce6cec8723c5ef">&#9670;&nbsp;</a></span>pi_i2s_channel_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_i2s_channel_write </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data to be sent by the I2S interface is stored first in the TX queue consisting of memory blocks preallocated by the user with either pingpong buffers or a memory slab allocator.</p>
<p>In pingpong mode, the driver will automatically alternate between 2 buffers and the user code is supposed to call this function to notify the driver that the specified buffer is ready to be sent. This is used by the driver to report when an underrun or an overrun occurs.</p>
<p>In memory slab allocator mode, the user has to allocate buffers from the memory slab allocator and pass them to the driver by calling this function when they are ready to be sent.</p>
<p>This fonction will block until the specified buffer has been transfered.</p>
<p>This will sent data to the specified channel and must only be used in TDM mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Pointer to the device structure for the driver instance. </td></tr>
    <tr><td class="paramname">channel</td><td>ID of the slot, from 0 to the number of channels minus 1. </td></tr>
    <tr><td class="paramname">mem_block</td><td>Pointer to the TX memory block containing data to be sent. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to write. This value has to be equal or smaller than the size of the memory block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If successful. </td></tr>
    <tr><td class="paramname">-1</td><td>An error occured. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga98f6d2597a9e1191fdf5b52acbd8ef4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98f6d2597a9e1191fdf5b52acbd8ef4a">&#9670;&nbsp;</a></span>pi_i2s_channel_write_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_i2s_channel_write_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data to be sent by the I2S interface is stored first in the TX queue consisting of memory blocks preallocated by the user with either pingpong buffers or a memory slab allocator.</p>
<p>In pingpong mode, the driver will automatically alternate between 2 buffers and the user code is supposed to call this function to notify the driver that the specified buffer is ready to be sent. This is used by the driver to report when an underrun or an overrun occurs.</p>
<p>In memory slab allocator mode, the user has to allocate buffers from the memory slab allocator and pass them to the driver by calling this function when they are ready to be sent.</p>
<p>This will sent data to the specified channel and must only be used in TDM mode.</p>
<p>The specified task will be pushed as soon as data is has been transfered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Pointer to the device structure for the driver instance. </td></tr>
    <tr><td class="paramname">channel</td><td>ID of the slot, from 0 to the number of channels minus 1. </td></tr>
    <tr><td class="paramname">mem_block</td><td>Pointer to the TX memory block containing data to be sent. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to write. This value has to be equal or smaller than the size of the memory block. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If successful. </td></tr>
    <tr><td class="paramname">-1</td><td>An error occured. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga899113b680f7f359c9dc69313e3bfd91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga899113b680f7f359c9dc69313e3bfd91">&#9670;&nbsp;</a></span>pi_i2s_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_i2s_close </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to close an opened I2S device once it is not needed anymore, in order to free all allocated resources. Once this function is called, the device is not accessible anymore and must be opened again before being used. The caller is blocked until the operation is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1657fc62c170475ec18210f1a57c329c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1657fc62c170475ec18210f1a57c329c">&#9670;&nbsp;</a></span>pi_i2s_conf_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_i2s_conf_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpi__i2s__conf.html">pi_i2s_conf</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to get default values for all parameters before setting some of them. The structure containing the configuration must be kept alive until the I2S device is opened.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>A pointer to the I2S configuration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6872494c60665461c4edb2b44d01c434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6872494c60665461c4edb2b44d01c434">&#9670;&nbsp;</a></span>pi_i2s_ioctl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_i2s_ioctl </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to change part of the device configuration after it has been opened or to control it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the structure describing the device. </td></tr>
    <tr><td class="paramname">cmd</td><td>The command which specifies which parameters of the driver to modify and for some of them also their values. The command must be one of those defined in pi_spi_ioctl_e. </td></tr>
    <tr><td class="paramname">arg</td><td>An additional value which is required for some parameters when they are set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac735eb27206159797c19a499c08a6cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac735eb27206159797c19a499c08a6cc5">&#9670;&nbsp;</a></span>pi_i2s_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_i2s_open </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function must be called before the I2S device can be used. It will do all the needed configuration to make it usable and initialize the handle used to refer to this opened device when calling other functions. The caller is blocked until the operation is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A pointer to the device structure of the device to open. This structure is allocated by the caller and must be kept alive until the device is closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the operation is successfull, -1 if there was an error. </dd></dl>

</div>
</div>
<a id="gac863071a455cc4ecde8b458650ddc6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac863071a455cc4ecde8b458650ddc6f4">&#9670;&nbsp;</a></span>pi_i2s_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_i2s_read </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>mem_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data received by the I2S interface is stored in the RX queue consisting of two memory blocks preallocated by the user and given to the driver in the configuration. Calling this function will return the next available buffer to the caller, which has to use it before the sampling for this buffer starts again.</p>
<p>The data is read in chunks equal to the size of the memory block.</p>
<p>When using several channels, the organization of the samples for each channel in the buffer, is chip-dependent, check the chip-specific documentation to get more information.</p>
<p>If there is no data in the RX queue the function will block waiting for the next RX memory block to fill in.</p>
<p>Due to hardware constraints, the address of the buffer must be aligned on 4 bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Pointer to the device structure for the driver instance. </td></tr>
    <tr><td class="paramname">mem_block</td><td>Pointer to the variable storing the address of the RX memory block containing received data. </td></tr>
    <tr><td class="paramname">size</td><td>Pointer to the variable storing the number of bytes read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If successful, -1 if not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4811af1f7fcd3a58e24f0e53eab040c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4811af1f7fcd3a58e24f0e53eab040c7">&#9670;&nbsp;</a></span>pi_i2s_read_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_i2s_read_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data received by the I2S interface is stored in the RX queue consisting of two memory blocks preallocated by the user and given to the driver in the configuration. Calling this function will return the next available buffer to the caller, which has to use it before the sampling for this buffer starts again.</p>
<p>The data is read in chunks equal to the size of the memory block.</p>
<p>When using several channels, the organization of the samples for each channel in the buffer, is chip-dependent, check the chip-specific documentation to get more information.</p>
<p>The specified task will be pushed as soon as data is ready in the RX queue, and the information about the memory block and the size will be available in the task.</p>
<p>Due to hardware constraints, the address of the buffer must be aligned on 4 bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Pointer to the device structure for the driver instance. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If successful, -1 if not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0ccba1a796f9cc90c4d9ec24b2c5040d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ccba1a796f9cc90c4d9ec24b2c5040d">&#9670;&nbsp;</a></span>pi_i2s_read_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_i2s_read_status </td>
          <td>(</td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>mem_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>After pi_i2s_read_async or pi_i2s_channel_read_async is called to be notified when a read buffer is available, and the notification is received, the output information can be retrieved by calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task used for notification. </td></tr>
    <tr><td class="paramname">mem_block</td><td>Pointer to the variable storing the address of the RX memory block containing received data. </td></tr>
    <tr><td class="paramname">size</td><td>Pointer to the variable storing the number of bytes read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If successful. </td></tr>
    <tr><td class="paramname">-1</td><td>An error occured. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga81800a8f3373400f3c187c205028b3db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81800a8f3373400f3c187c205028b3db">&#9670;&nbsp;</a></span>pi_i2s_setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_i2s_setup </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to set specific I2S properties such as the number of clock generator. This is typically used by the BSP to give board specific information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>A bitfield of chip-dependant properties. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0694992fc5b378d2b37ca25b5f2fe813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0694992fc5b378d2b37ca25b5f2fe813">&#9670;&nbsp;</a></span>pi_i2s_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_i2s_write </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data to be sent by the I2S interface is stored first in the TX queue consisting of memory blocks preallocated by the user with either pingpong buffers or a memory slab allocator.</p>
<p>In pingpong mode, the driver will automatically alternate between 2 buffers and the user code is supposed to call this function to notify the driver that the specified buffer is ready to be sent. This is used by the driver to report when an underrun or an overrun occurs.</p>
<p>In memory slab allocator mode, the user has to allocate buffers from the memory slab allocator and pass them to the driver by calling this function when they are ready to be sent.</p>
<p>This fonction will block until the specified buffer has been transfered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Pointer to the device structure for the driver instance. </td></tr>
    <tr><td class="paramname">mem_block</td><td>Pointer to the TX memory block containing data to be sent. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to write. This value has to be equal or smaller than the size of the memory block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If successful. </td></tr>
    <tr><td class="paramname">-1</td><td>An error occured. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4207e7758220e085a86eac7c7c400703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4207e7758220e085a86eac7c7c400703">&#9670;&nbsp;</a></span>pi_i2s_write_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_i2s_write_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data to be sent by the I2S interface is stored first in the TX queue consisting of memory blocks preallocated by the user with either pingpong buffers or a memory slab allocator.</p>
<p>In pingpong mode, the driver will automatically alternate between 2 buffers and the user code is supposed to call this function to notify the driver that the specified buffer is ready to be sent. This is used by the driver to report when an underrun or an overrun occurs.</p>
<p>In memory slab allocator mode, the user has to allocate buffers from the memory slab allocator and pass them to the driver by calling this function when they are ready to be sent.</p>
<p>The specified task will be pushed as soon as data is has been transfered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>Pointer to the device structure for the driver instance. </td></tr>
    <tr><td class="paramname">mem_block</td><td>Pointer to the TX memory block containing data to be sent. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to write. This value has to be equal or smaller than the size of the memory block. </td></tr>
    <tr><td class="paramname">task</td><td>The task used to notify the end of transfer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If successful. </td></tr>
    <tr><td class="paramname">-1</td><td>An error occured. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga791f0081e66282503606188a6564c5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga791f0081e66282503606188a6564c5e0">&#9670;&nbsp;</a></span>pi_i2s_write_status()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_i2s_write_status </td>
          <td>(</td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>After pi_i2s_write_async or pi_i2s_channel_write_async and the notification for the end of transfer is received, return value can be retrieved by calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task used for notification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If successful. </td></tr>
    <tr><td class="paramname">-1</td><td>An error occured. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Sep 7 2020 11:22:11 for  by GreenWaves Technologies
	<!--
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 
	-->
	</li>
  </ul>
</div>
</body>
</html>
