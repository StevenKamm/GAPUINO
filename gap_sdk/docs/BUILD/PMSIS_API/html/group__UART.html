<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>UART</title>
<title>UART</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="pulp.css" rel="stylesheet" type="text/css" />
<link href="gap.css" rel="stylesheet" type="text/css" />
<link href="images.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="titlerow">
  <td id="projectlogo"><img alt="Logo" src="gap-logo-55.png" /></td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">PMSIS API</div>
    </td>
  <td id="extralogo"><img alt="GreenWaves" src="greenwaves-logo-55.png" /></td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
    <ul class="tablist">
      <script type="text/javascript">
		<!--
		writeComponentTabs.call(this);
		//-->
      </script>
	  </ul>
</div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__UART.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">UART<div class="ingroups"><a class="el" href="group__groupDrivers.html">Drivers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>UART Universal Asynchronous Receiver Transmitter.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpi__uart__conf.html">pi_uart_conf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART device configuration structure.  <a href="structpi__uart__conf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5f18274f56cb237e94d317a67e0882b0"><td class="memItemLeft" align="right" valign="top">typedef struct pi_cl_uart_req_s&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a></td></tr>
<tr class="memdesc:ga5f18274f56cb237e94d317a67e0882b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART cluster request structure.  <a href="#ga5f18274f56cb237e94d317a67e0882b0">More...</a><br /></td></tr>
<tr class="separator:ga5f18274f56cb237e94d317a67e0882b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gabdfddf3a850d4eece9e6c9542e23472b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#gabdfddf3a850d4eece9e6c9542e23472b">pi_uart_stop_bits</a> <tr class="memdesc:gabdfddf3a850d4eece9e6c9542e23472b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop bits enum.  <a href="group__UART.html#gabdfddf3a850d4eece9e6c9542e23472b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gabdfddf3a850d4eece9e6c9542e23472b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65a930cab1c0d936fd2df26ebdcb3814"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga65a930cab1c0d936fd2df26ebdcb3814">pi_uart_parity_mode</a> <tr class="memdesc:ga65a930cab1c0d936fd2df26ebdcb3814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parity mode enum.  <a href="group__UART.html#ga65a930cab1c0d936fd2df26ebdcb3814">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga65a930cab1c0d936fd2df26ebdcb3814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f3a973fc9c5783a4390626b43adfed4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga6f3a973fc9c5783a4390626b43adfed4">pi_uart_word_size</a> <tr class="memdesc:ga6f3a973fc9c5783a4390626b43adfed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit length of each word.  <a href="group__UART.html#ga6f3a973fc9c5783a4390626b43adfed4">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga6f3a973fc9c5783a4390626b43adfed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b6406f3474083f724852dd15d4ae960"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga1b6406f3474083f724852dd15d4ae960">pi_uart_ioctl_cmd</a> <tr class="memdesc:ga1b6406f3474083f724852dd15d4ae960"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART ioctl commands.  <a href="group__UART.html#ga1b6406f3474083f724852dd15d4ae960">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga1b6406f3474083f724852dd15d4ae960"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8c26b46bd5eb4ee4177e6027a69a55bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga8c26b46bd5eb4ee4177e6027a69a55bc">pi_uart_conf_init</a> (struct <a class="el" href="structpi__uart__conf.html">pi_uart_conf</a> *conf)</td></tr>
<tr class="memdesc:ga8c26b46bd5eb4ee4177e6027a69a55bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a UART configuration with default values.  <a href="#ga8c26b46bd5eb4ee4177e6027a69a55bc">More...</a><br /></td></tr>
<tr class="separator:ga8c26b46bd5eb4ee4177e6027a69a55bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21def19994b46489a8ffa4cf030e9794"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga21def19994b46489a8ffa4cf030e9794">pi_uart_open</a> (struct pi_device *device)</td></tr>
<tr class="memdesc:ga21def19994b46489a8ffa4cf030e9794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a UART device.  <a href="#ga21def19994b46489a8ffa4cf030e9794">More...</a><br /></td></tr>
<tr class="separator:ga21def19994b46489a8ffa4cf030e9794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bb339477c7ccb7b91d1ddfe949dbbd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga6bb339477c7ccb7b91d1ddfe949dbbd1">pi_uart_close</a> (struct pi_device *device)</td></tr>
<tr class="memdesc:ga6bb339477c7ccb7b91d1ddfe949dbbd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close an opened UART device.  <a href="#ga6bb339477c7ccb7b91d1ddfe949dbbd1">More...</a><br /></td></tr>
<tr class="separator:ga6bb339477c7ccb7b91d1ddfe949dbbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec90ff01db9d3b6a7fbbe9bf7b9c2849"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#gaec90ff01db9d3b6a7fbbe9bf7b9c2849">pi_uart_ioctl</a> (struct pi_device *device, uint32_t cmd, void *arg)</td></tr>
<tr class="memdesc:gaec90ff01db9d3b6a7fbbe9bf7b9c2849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically change device configuration.  <a href="#gaec90ff01db9d3b6a7fbbe9bf7b9c2849">More...</a><br /></td></tr>
<tr class="separator:gaec90ff01db9d3b6a7fbbe9bf7b9c2849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga953a8ceefcc5a33871dd32c4d9a9ef35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga953a8ceefcc5a33871dd32c4d9a9ef35">pi_uart_write</a> (struct pi_device *device, void *buffer, uint32_t size)</td></tr>
<tr class="memdesc:ga953a8ceefcc5a33871dd32c4d9a9ef35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to an UART.  <a href="#ga953a8ceefcc5a33871dd32c4d9a9ef35">More...</a><br /></td></tr>
<tr class="separator:ga953a8ceefcc5a33871dd32c4d9a9ef35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa902ab4ee7d2023375e1319d4ad1a51e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#gaa902ab4ee7d2023375e1319d4ad1a51e">pi_uart_read</a> (struct pi_device *device, void *buffer, uint32_t size)</td></tr>
<tr class="memdesc:gaa902ab4ee7d2023375e1319d4ad1a51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from an UART.  <a href="#gaa902ab4ee7d2023375e1319d4ad1a51e">More...</a><br /></td></tr>
<tr class="separator:gaa902ab4ee7d2023375e1319d4ad1a51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47076425f15e54cc170f32259fddcca6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga47076425f15e54cc170f32259fddcca6">pi_uart_write_byte</a> (struct pi_device *device, uint8_t *byte)</td></tr>
<tr class="memdesc:ga47076425f15e54cc170f32259fddcca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a byte to an UART.  <a href="#ga47076425f15e54cc170f32259fddcca6">More...</a><br /></td></tr>
<tr class="separator:ga47076425f15e54cc170f32259fddcca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01778d12b41a16cf0c6e61161b854a3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga01778d12b41a16cf0c6e61161b854a3e">pi_uart_read_byte</a> (struct pi_device *device, uint8_t *byte)</td></tr>
<tr class="memdesc:ga01778d12b41a16cf0c6e61161b854a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a byte from an UART.  <a href="#ga01778d12b41a16cf0c6e61161b854a3e">More...</a><br /></td></tr>
<tr class="separator:ga01778d12b41a16cf0c6e61161b854a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae27ad3c7ffe2bc97c251a833189d2121"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#gae27ad3c7ffe2bc97c251a833189d2121">pi_uart_write_async</a> (struct pi_device *device, void *buffer, uint32_t size, pi_task_t *callback)</td></tr>
<tr class="memdesc:gae27ad3c7ffe2bc97c251a833189d2121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to an UART asynchronously.  <a href="#gae27ad3c7ffe2bc97c251a833189d2121">More...</a><br /></td></tr>
<tr class="separator:gae27ad3c7ffe2bc97c251a833189d2121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada5035f9fd4b858f8326c8b30d254e56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#gada5035f9fd4b858f8326c8b30d254e56">pi_uart_read_async</a> (struct pi_device *device, void *buffer, uint32_t size, pi_task_t *callback)</td></tr>
<tr class="memdesc:gada5035f9fd4b858f8326c8b30d254e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from an UART asynchronously.  <a href="#gada5035f9fd4b858f8326c8b30d254e56">More...</a><br /></td></tr>
<tr class="separator:gada5035f9fd4b858f8326c8b30d254e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a32e4b740d4949371ed44c564f640c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga5a32e4b740d4949371ed44c564f640c7">pi_uart_write_byte_async</a> (struct pi_device *device, uint8_t *byte, pi_task_t *callback)</td></tr>
<tr class="memdesc:ga5a32e4b740d4949371ed44c564f640c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a byte to an UART asynchronously.  <a href="#ga5a32e4b740d4949371ed44c564f640c7">More...</a><br /></td></tr>
<tr class="separator:ga5a32e4b740d4949371ed44c564f640c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga156527715f9648a683a3065833cf96fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga156527715f9648a683a3065833cf96fd">pi_cl_uart_write</a> (pi_device_t *device, void *buffer, uint32_t size, <a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *req)</td></tr>
<tr class="memdesc:ga156527715f9648a683a3065833cf96fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to an UART from cluster side.  <a href="#ga156527715f9648a683a3065833cf96fd">More...</a><br /></td></tr>
<tr class="separator:ga156527715f9648a683a3065833cf96fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac447ba2c94ca588fe15c2ddd5225bfc1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#gac447ba2c94ca588fe15c2ddd5225bfc1">pi_cl_uart_write_byte</a> (pi_device_t *device, uint8_t *byte, <a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *req)</td></tr>
<tr class="memdesc:gac447ba2c94ca588fe15c2ddd5225bfc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a byte to an UART from cluster side.  <a href="#gac447ba2c94ca588fe15c2ddd5225bfc1">More...</a><br /></td></tr>
<tr class="separator:gac447ba2c94ca588fe15c2ddd5225bfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga336e8f3573b9c9df85cd13cc9af42210"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga336e8f3573b9c9df85cd13cc9af42210">pi_cl_uart_write_wait</a> (<a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *req)</td></tr>
<tr class="memdesc:ga336e8f3573b9c9df85cd13cc9af42210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the specified UART cluster write request has finished.  <a href="#ga336e8f3573b9c9df85cd13cc9af42210">More...</a><br /></td></tr>
<tr class="separator:ga336e8f3573b9c9df85cd13cc9af42210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a71ba2ea0ab821b1f0d65ef75c96aa3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#ga1a71ba2ea0ab821b1f0d65ef75c96aa3">pi_cl_uart_read</a> (pi_device_t *device, void *buffer, uint32_t size, <a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *req)</td></tr>
<tr class="memdesc:ga1a71ba2ea0ab821b1f0d65ef75c96aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a byte from an UART from cluster side.  <a href="#ga1a71ba2ea0ab821b1f0d65ef75c96aa3">More...</a><br /></td></tr>
<tr class="separator:ga1a71ba2ea0ab821b1f0d65ef75c96aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5c94eab051c6dd60c1bf1bfd421bd21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#gaa5c94eab051c6dd60c1bf1bfd421bd21">pi_cl_uart_read_byte</a> (pi_device_t *device, uint8_t *byte, <a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *req)</td></tr>
<tr class="memdesc:gaa5c94eab051c6dd60c1bf1bfd421bd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a byte from an UART.  <a href="#gaa5c94eab051c6dd60c1bf1bfd421bd21">More...</a><br /></td></tr>
<tr class="separator:gaa5c94eab051c6dd60c1bf1bfd421bd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4311ef784433dff113c2899e13a5f70"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UART.html#gab4311ef784433dff113c2899e13a5f70">pi_cl_uart_read_wait</a> (<a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *req)</td></tr>
<tr class="memdesc:gab4311ef784433dff113c2899e13a5f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until the specified UART cluster read request has finished.  <a href="#gab4311ef784433dff113c2899e13a5f70">More...</a><br /></td></tr>
<tr class="separator:gab4311ef784433dff113c2899e13a5f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>This API provides support for transferring data between an external UART device and the processor running this driver. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga5f18274f56cb237e94d317a67e0882b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f18274f56cb237e94d317a67e0882b0">&#9670;&nbsp;</a></span>pi_cl_uart_req_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct pi_cl_uart_req_s <a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure is used by the runtime to manage a cluster remote copy with the UART. It must be instantiated once for each copy and must be kept alive until the copy is finished. It can be instantiated as a normal variable, for example as a global variable, a local one on the stack, or through a memory allocator. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga1b6406f3474083f724852dd15d4ae960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b6406f3474083f724852dd15d4ae960">&#9670;&nbsp;</a></span>pi_uart_ioctl_cmd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__UART.html#ga1b6406f3474083f724852dd15d4ae960">pi_uart_ioctl_cmd</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UART ioctl commands to configure, enable device. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1b6406f3474083f724852dd15d4ae960a9d7d126a1b30a3f0b4a22fbf8c077acb"></a>PI_UART_IOCTL_CONF_SETUP&#160;</td><td class="fielddoc"><p>Setup UART device. </p>
<p>Setup UART with given conf. The parameter for this command is a struct <a class="el" href="structpi__uart__conf.html" title="UART device configuration structure. ">pi_uart_conf</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>Pointer to struct <a class="el" href="structpi__uart__conf.html" title="UART device configuration structure. ">pi_uart_conf</a>. </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a id="gga1b6406f3474083f724852dd15d4ae960aae735313e35fd4cbdadb12e92cf8b36d"></a>PI_UART_IOCTL_ABORT_RX&#160;</td><td class="fielddoc"><p>Abort RX transfers. </p>
<p>Disable RX channel, abort current RX transfert, and flush all pending transferts.</p>
<dl class="section note"><dt>Note</dt><dd>This function disables reception channel after clearing UDMA channels. In order to send again data, the reception channel must re-enabled. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga1b6406f3474083f724852dd15d4ae960a373fddc284066ceba35264410fb50c15"></a>PI_UART_IOCTL_ABORT_TX&#160;</td><td class="fielddoc"><p>Abort TX transfers. </p>
<p>Disable TX channel, abort current TX transfert, and flush all pending transferts.</p>
<dl class="section note"><dt>Note</dt><dd>This function disables transmission channel after clearing UDMA channels. In order to send again data, the transmission channel must re-enabled. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga1b6406f3474083f724852dd15d4ae960aa6827c7c553c52e768c18e29d604a743"></a>PI_UART_IOCTL_ENABLE_RX&#160;</td><td class="fielddoc"><p>Enable reception. </p>
<p>This command enables reception on UART device. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1b6406f3474083f724852dd15d4ae960a642b7c28790d35559a792faff49680ee"></a>PI_UART_IOCTL_ENABLE_TX&#160;</td><td class="fielddoc"><p>Enable transmission. </p>
<p>This command enables transmission on UART device. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1b6406f3474083f724852dd15d4ae960a4cb3679ca86322d56eeaeb4eb94fe23c"></a>PI_UART_IOCTL_ENABLE_FLOW_CONTROL&#160;</td><td class="fielddoc"><p>Enable flow control. </p>
<p>This command enables flow control on UART device.</p>
<dl class="section note"><dt>Note</dt><dd>On GAP8, flow control is emulated using a PWM device(Timer0, channel2) and two GPIOs(PI_GPIO_A1_PAD_9_B3, PI_GPIO_A0_PAD_8_A4). </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga1b6406f3474083f724852dd15d4ae960a2ea79e2f38222d7de71ace6017e4da61"></a>PI_UART_IOCTL_DISABLE_FLOW_CONTROL&#160;</td><td class="fielddoc"><p>Disable flow control. </p>
<p>This command disables flow control on UART device. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1b6406f3474083f724852dd15d4ae960a871558f1d9b598add50e85db6719090b"></a>PI_UART_IOCTL_FLUSH&#160;</td><td class="fielddoc"><p>Flush UART TX. </p>
<p>This command will wait until all pending buffers are flushed outside </p>
</td></tr>
</table>

</div>
</div>
<a id="ga65a930cab1c0d936fd2df26ebdcb3814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65a930cab1c0d936fd2df26ebdcb3814">&#9670;&nbsp;</a></span>pi_uart_parity_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__UART.html#ga65a930cab1c0d936fd2df26ebdcb3814">pi_uart_parity_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga65a930cab1c0d936fd2df26ebdcb3814a1b45159ce956c2d337ba3203e2dce244"></a>PI_UART_PARITY_DISABLE&#160;</td><td class="fielddoc"><p>Disable parity mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga65a930cab1c0d936fd2df26ebdcb3814ace3711bb6bd6662a32b344bfc3b85e88"></a>PI_UART_PARITY_ENABLE&#160;</td><td class="fielddoc"><p>Enable parity mode. </p>
</td></tr>
</table>

</div>
</div>
<a id="gabdfddf3a850d4eece9e6c9542e23472b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdfddf3a850d4eece9e6c9542e23472b">&#9670;&nbsp;</a></span>pi_uart_stop_bits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__UART.html#gabdfddf3a850d4eece9e6c9542e23472b">pi_uart_stop_bits</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabdfddf3a850d4eece9e6c9542e23472bab0db4133445e89f799bfb55d8c199269"></a>PI_UART_STOP_BITS_ONE&#160;</td><td class="fielddoc"><p>One stop bit. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabdfddf3a850d4eece9e6c9542e23472baff1fb3b64d6336f412ec505d60efeec8"></a>PI_UART_STOP_BITS_TWO&#160;</td><td class="fielddoc"><p>Two stop bits. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga6f3a973fc9c5783a4390626b43adfed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f3a973fc9c5783a4390626b43adfed4">&#9670;&nbsp;</a></span>pi_uart_word_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__UART.html#ga6f3a973fc9c5783a4390626b43adfed4">pi_uart_word_size</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6f3a973fc9c5783a4390626b43adfed4a5cdbb5cb92588bfc1e8630071895d7fa"></a>PI_UART_WORD_SIZE_5_BITS&#160;</td><td class="fielddoc"><p>5 bits length. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6f3a973fc9c5783a4390626b43adfed4a115cec7e39a9d503b603ce76e8cc7fc4"></a>PI_UART_WORD_SIZE_6_BITS&#160;</td><td class="fielddoc"><p>6 bits length. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6f3a973fc9c5783a4390626b43adfed4abb87290b1698476db57986833ed7be81"></a>PI_UART_WORD_SIZE_7_BITS&#160;</td><td class="fielddoc"><p>7 bits length. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6f3a973fc9c5783a4390626b43adfed4a733803195aface4aea82f8c1330a03cc"></a>PI_UART_WORD_SIZE_8_BITS&#160;</td><td class="fielddoc"><p>8 bits length. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1a71ba2ea0ab821b1f0d65ef75c96aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a71ba2ea0ab821b1f0d65ef75c96aa3">&#9670;&nbsp;</a></span>pi_cl_uart_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_cl_uart_read </td>
          <td>(</td>
          <td class="paramtype">pi_device_t *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function implements the same feature as pi_uart_read_byte but can be called from cluster side in order to expose the feature on the cluster. A pointer to a request structure must be provided so that the runtime can properly do the remote call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>Pointer to device descriptor of the UART device. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to data buffer. </td></tr>
    <tr><td class="paramname">size</td><td>Size of data to copy in bytes. </td></tr>
    <tr><td class="paramname">req</td><td>Request structure used for termination.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If operation is successfull. </td></tr>
    <tr><td class="paramname">ERRNO</td><td>An error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa5c94eab051c6dd60c1bf1bfd421bd21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5c94eab051c6dd60c1bf1bfd421bd21">&#9670;&nbsp;</a></span>pi_cl_uart_read_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_cl_uart_read_byte </td>
          <td>(</td>
          <td class="paramtype">pi_device_t *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This reads a byte from the specified UART. The caller is blocked until the transfer is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>Pointer to device descriptor of the UART device. </td></tr>
    <tr><td class="paramname">byte</td><td>Pointer to data buffer. </td></tr>
    <tr><td class="paramname">req</td><td>Request structure used for termination.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If operation is successfull. </td></tr>
    <tr><td class="paramname">ERRNO</td><td>An error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab4311ef784433dff113c2899e13a5f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4311ef784433dff113c2899e13a5f70">&#9670;&nbsp;</a></span>pi_cl_uart_read_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cl_uart_read_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This blocks the calling core until the specified cluster remote copy is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>Request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga156527715f9648a683a3065833cf96fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga156527715f9648a683a3065833cf96fd">&#9670;&nbsp;</a></span>pi_cl_uart_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_cl_uart_write </td>
          <td>(</td>
          <td class="paramtype">pi_device_t *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function implements the same feature as pi_uart_write but can be called from cluster side in order to expose the feature on the cluster. A pointer to a request structure must be provided so that the runtime can properly do the remote call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>Pointer to device descriptor of the UART device. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to data buffer. </td></tr>
    <tr><td class="paramname">size</td><td>Size of data to copy in bytes. </td></tr>
    <tr><td class="paramname">req</td><td>Request structure used for termination.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If operation is successfull. </td></tr>
    <tr><td class="paramname">ERRNO</td><td>An error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac447ba2c94ca588fe15c2ddd5225bfc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac447ba2c94ca588fe15c2ddd5225bfc1">&#9670;&nbsp;</a></span>pi_cl_uart_write_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_cl_uart_write_byte </td>
          <td>(</td>
          <td class="paramtype">pi_device_t *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function implements the same feature as pi_uart_write_byte but can be called from cluster side in order to expose the feature on the cluster. A pointer to a request structure must be provided so that the runtime can properly do the remote call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>Pointer to device descriptor of the UART device. </td></tr>
    <tr><td class="paramname">byte</td><td>Pointer to data buffer. </td></tr>
    <tr><td class="paramname">req</td><td>Request structure used for termination.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If operation is successfull. </td></tr>
    <tr><td class="paramname">ERRNO</td><td>An error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga336e8f3573b9c9df85cd13cc9af42210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga336e8f3573b9c9df85cd13cc9af42210">&#9670;&nbsp;</a></span>pi_cl_uart_write_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pi_cl_uart_write_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__UART.html#ga5f18274f56cb237e94d317a67e0882b0">pi_cl_uart_req_t</a> *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This blocks the calling core until the specified cluster remote copy is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>Request structure used for termination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6bb339477c7ccb7b91d1ddfe949dbbd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bb339477c7ccb7b91d1ddfe949dbbd1">&#9670;&nbsp;</a></span>pi_uart_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_uart_close </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to close an opened UART device once it is not needed anymore, in order to free all allocated resources. Once this function is called, the device is not accessible anymore and must be opened again before being used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>Pointer to device structure of the device to close. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8c26b46bd5eb4ee4177e6027a69a55bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c26b46bd5eb4ee4177e6027a69a55bc">&#9670;&nbsp;</a></span>pi_uart_conf_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pi_uart_conf_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpi__uart__conf.html">pi_uart_conf</a> *&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function can be called to get default values for all parameters before setting some of them. The structure containing the configuration must be kept alive until the uart device is opened.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>Pointer to the UART configuration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaec90ff01db9d3b6a7fbbe9bf7b9c2849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec90ff01db9d3b6a7fbbe9bf7b9c2849">&#9670;&nbsp;</a></span>pi_uart_ioctl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_uart_ioctl </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function allows to send different commands to UART device. The commands are listed above, cf. enum pi_uart_ioctl_cmd.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>Pointer to device descriptor of the UART device. </td></tr>
    <tr><td class="paramname">cmd</td><td>Ioctl command. </td></tr>
    <tr><td class="paramname">arg</td><td>Ioctl command args.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-1</td><td>If wrong ioctl command. </td></tr>
    <tr><td class="paramname">Value</td><td>Otherwise return value depending on ioctl command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga21def19994b46489a8ffa4cf030e9794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21def19994b46489a8ffa4cf030e9794">&#9670;&nbsp;</a></span>pi_uart_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_uart_open </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function must be called before the UART device can be used. It will do all the needed configuration to make it usable and initialize the handle used to refer to this opened device when calling other functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>Pointer to device structure of the device to open.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If the operation is successfull. </td></tr>
    <tr><td class="paramname">ERRNO</td><td>An error code otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This structure is allocated by the called and must be kept alive until the device is closed. </dd></dl>

</div>
</div>
<a id="gaa902ab4ee7d2023375e1319d4ad1a51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa902ab4ee7d2023375e1319d4ad1a51e">&#9670;&nbsp;</a></span>pi_uart_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_uart_read </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This reads data from the specified UART. The caller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>Pointer to device descriptor of the UART device. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to data buffer. </td></tr>
    <tr><td class="paramname">size</td><td>Size of data to copy in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If operation is successfull. </td></tr>
    <tr><td class="paramname">ERRNO</td><td>An error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gada5035f9fd4b858f8326c8b30d254e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada5035f9fd4b858f8326c8b30d254e56">&#9670;&nbsp;</a></span>pi_uart_read_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_uart_read_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This reads data from the specified UART asynchronously. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>Pointer to device descriptor of the UART device. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to data buffer. </td></tr>
    <tr><td class="paramname">size</td><td>Size of data to copy in bytes. </td></tr>
    <tr><td class="paramname">callback</td><td>Event task used to notify the end of transfer. See the documentation of pi_task_t for more details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If operation is successfull. </td></tr>
    <tr><td class="paramname">ERRNO</td><td>An error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga01778d12b41a16cf0c6e61161b854a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01778d12b41a16cf0c6e61161b854a3e">&#9670;&nbsp;</a></span>pi_uart_read_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_uart_read_byte </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This reads a byte from the specified UART. The caller is blocked until the transfer is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>Pointer to device descriptor of the UART device. </td></tr>
    <tr><td class="paramname">byte</td><td>Pointer to data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If operation is successfull. </td></tr>
    <tr><td class="paramname">ERRNO</td><td>An error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga953a8ceefcc5a33871dd32c4d9a9ef35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga953a8ceefcc5a33871dd32c4d9a9ef35">&#9670;&nbsp;</a></span>pi_uart_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_uart_write </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This writes data to the specified UART. The caller is blocked until the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>Pointer to device descriptor of the UART device. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to data buffer. </td></tr>
    <tr><td class="paramname">size</td><td>Size of data to copy in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If operation is successfull. </td></tr>
    <tr><td class="paramname">ERRNO</td><td>An error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae27ad3c7ffe2bc97c251a833189d2121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae27ad3c7ffe2bc97c251a833189d2121">&#9670;&nbsp;</a></span>pi_uart_write_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_uart_write_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This writes data to the specified UART asynchronously. A task must be specified in order to specify how the caller should be notified when the transfer is finished. Depending on the chip, there may be some restrictions on the memory which can be used. Check the chip-specific documentation for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>Pointer to device descriptor of the UART device. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to data buffer. </td></tr>
    <tr><td class="paramname">size</td><td>Size of data to copy in bytes. </td></tr>
    <tr><td class="paramname">callback</td><td>Event task used to notify the end of transfer. See the documentation of pi_task_t for more details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If operation is successfull. </td></tr>
    <tr><td class="paramname">ERRNO</td><td>An error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga47076425f15e54cc170f32259fddcca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47076425f15e54cc170f32259fddcca6">&#9670;&nbsp;</a></span>pi_uart_write_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_uart_write_byte </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This writes a byte to the specified UART. The caller is blocked until the transfer is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>Pointer to device descriptor of the UART device. </td></tr>
    <tr><td class="paramname">byte</td><td>Pointer to data buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If operation is successfull. </td></tr>
    <tr><td class="paramname">ERRNO</td><td>An error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5a32e4b740d4949371ed44c564f640c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a32e4b740d4949371ed44c564f640c7">&#9670;&nbsp;</a></span>pi_uart_write_byte_async()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pi_uart_write_byte_async </td>
          <td>(</td>
          <td class="paramtype">struct pi_device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pi_task_t *&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This writes a byte to the specified UART asynchronously. A task must be specified in order to specify how the caller should be notified when the transfer is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>Pointer to device descriptor of the UART device. </td></tr>
    <tr><td class="paramname">byte</td><td>Pointer to data buffer. </td></tr>
    <tr><td class="paramname">callback</td><td>Event task used to notify the end of transfer. See the documentation of pi_task_t for more details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If operation is successfull. </td></tr>
    <tr><td class="paramname">ERRNO</td><td>An error code otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Sep 7 2020 11:22:11 for  by GreenWaves Technologies
	<!--
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 
	-->
	</li>
  </ul>
</div>
</body>
</html>
